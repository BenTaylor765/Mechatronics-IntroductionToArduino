{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction to Arduino Labs","text":"<p>Danger: Read This First!</p> <p>Before proceeding with further through this documentation or making any of the circuits discussed within, you must read the Disclaimer for using your personal Laptop or MacBook.</p> <p>Before Starting the Exercises</p> <p>Before starting the laboratory exercises, you should review the contents of the Mechatronics KIT Information folder, located in the Practicals content area of the Blackboard site for the Mechatronics course.</p> <p>Note: Open This website on the computer you are programming your Arduino on</p> <p>It is recommended that you open this website on the computer that you are doing your coding on, because there are several code examples that you can cut and paste directly from these documents into your working code.</p>"},{"location":"#introduction","title":"Introduction","text":"<p>During this activity you will have three laboratory sessions to complete a number of laboratory exercises, based around a simple mobile robotic chassis, as shown in Fig. 1.</p> Picture of the completed robot chassis."},{"location":"#documentation-layout","title":"Documentation Layout","text":"<p>The Documentation is laid out in the following sections:</p> <ul> <li>This Introduction: A quick overview of this section of the course, providing aims and objectives, structure of laboratory sessions, and a suggested timeline for your work.</li> <li>Laptop Disclaimer: Read this before continuing</li> <li>Building the Robot Chassis Document: This document describes the building and recommended layout for the electronic circuit</li> <li>Introductory and Supplementary Material: There are two documents in this section<ul> <li>Supplementary Signposting Document: This document is aimed at students with little or no C-programming experience, but maybe used as a signposted reference for anyone. This document provides links to external websites and the Arduino reference pages.</li> <li>Introductory Exercises:This document provides you with two non-assessed exercises aimed at getting you started with installing and setting up the Arduino IDE, ready for use with these laboratory activities, and programming with simple I/O.</li> </ul> </li> <li>Basic Exercises: This section provides six basic, assessed exercises aimed at reading sensors and driving actuators. These exercises are aimed at providing you with the scaffolding to for the more advanced integration exercises.</li> <li>Advanced Exercises: This section contains 3 advanced, assessed exercises, which require you to integrate the sensors and actuators learning from the basic exercises into simple mechatronics systems. During these exercises, we will introduce the programming of a PI controller and use a simple finite state machine. </li> <li>Assessment Section: This section more details relating to the assessment and marking for all the exercises.</li> </ul> <p>Note</p> <p>You must have completed and have marked off all the basic exercises before you can receive credit for any of the advanced exercises.</p>"},{"location":"#aims-and-objectives","title":"Aims and Objectives","text":"<p>The aims of these laboratory exercises are:</p> <ul> <li>To familiarize yourself with the Arduino Development Environment, IDE</li> <li>Gain experience of uploading user programs to the embedded target</li> <li>Provide you with hands-on experience of reading analogue sensor voltages into the Arduino device</li> <li>To convert these sensor values into meaningful measurement variables. </li> <li>To drive different type of actuators using a PWM output from an Arduino device, </li> <li>Use sensor information to adjust the behaviour of a system</li> </ul> <p>To achieve these aims, the laboratory exercises are split into several assessed exercises, some are classed as basic and some advanced. A suggested timeline for achieving the Basic Exercises is provided in the later in this section of this documentation.</p> <p>To achieve the Advanced Exercises you will need to put in extra effort, outside the laboratory sessions, to fulfil the requirements.</p> <p>A list of the assessed exercises, with hyperlinks is provided:</p> <ul> <li>Basic: LED Pattern</li> <li>Basic: Calibration of Potentiometer Angle</li> <li>Basic: IR Sensor Measurement + Graph</li> <li>Basic: Externally Powered Servo</li> <li>Basic: DC Motor</li> <li>Basic: Encoders + Motor</li> <li>Advanced: PI Control \u2013 IR Sensor Distance</li> <li>Advanced: PI Control \u2013 Encoder Position</li> <li>Advanced: PI Control \u2013 IR with Sequence</li> </ul> <p>Each of these exercises will be assessed during the laboratory session, using the assessment structure outlined in the Appendix section of this document. When you have completed an assessed exercise, you should get your work marked one of the GTAs. </p> <p>Warning</p> <p>DO NOT leave all your exercises until the end of the 3rd laboratory session to get marked. This may result in you running out of time to get your work marked within the allotted time, and you will lose marks. Instead, you should get your work marked as you complete each assessed exercise \u2013 see note below:</p>"},{"location":"#structure-of-laboratory-sessions","title":"Structure of Laboratory Sessions","text":"<p>The hardware kits that you will be using during these exercises are loaned to you for the duration of the Mechatronics module and you will take them home between laboratory and project sessions. </p> <p>Note</p> <p>We will provide 3 supported laboratory sessions for you to work in, but you are also expected to do some work at home to ensure that you have completed all the exercises AND have them marked before the end of the 3rd laboratory session. 15 minutes before the end of the 3rd Introduction to Arduino laboratory session, we will stop marking work, with the remainder of the time being available for tidying your work area and exiting the laboratory. Any exercises not marked before this deadline, (regardless of whether they have been completed or not), will be forfeit and you will lose these marks. Please ensure that you get your work marked incrementally as you proceed through the exercises, and not leave them until the final moments, to avoid disappointment. </p> <p>You can have any of the assessed exercises marked at any point during the three laboratory sessions, as long as there is someone free to mark your work.</p>"},{"location":"#suggested-timeline-for-your-work","title":"Suggested Timeline for your Work","text":"<p> There is no rigid structure for your progress through these exercises, but the following time plan should be sufficient to ensure that you have time to complete all the exercises and have them marked by the GTAs before the end of the 3<sup>rd</sup> laboratory session.</p>"},{"location":"#by-the-end-of-the-1st-lab-session","title":"By the end of the 1<sup>st</sup> lab session","text":"<p>By the end of the 1<sup>st</sup> lab session, it is recommended that you have had the following exercises completed and marked:</p> <ul> <li>Constructed the Robot Chassis <li>Basic: LED Pattern</li>"},{"location":"#before-the-start-of-the-2nd-lab-session","title":"Before the start of the 2<sup>nd</sup> lab session","text":"<p>Before the start of the 2nd lab session, it is recommended that you have a working circuit capable of performing:</p> <ul> <li>Basic: Calibration of Potentiometer Angle</li> </ul> <p>You should also ensure that you have read the exercise document, linked above. Ensure you have understood all the procedures.</p>"},{"location":"#by-the-end-of-the-2nd-lab-session","title":"By the end of the 2<sup>nd</sup> lab session","text":"<p>By the end of the 2<sup>nd</sup> laboratory session, it is recommended that you have the following exercises completed and marked:</p> <ul> <li>Basic: Calibration of Potentiometer Angle</li> <li>Basic: Externally Powered Servo</li> <li>Basic: DC Motor</li> </ul>"},{"location":"#before-the-start-of-the-3rd-lab-session","title":"Before the start of the 3<sup>rd</sup> lab session","text":"<p>Before the start of the 3<sup>rd</sup> lab session, it is recommended that you have a working circuit capable of performing:</p> <ul> <li>Basic: Encoders + Motor</li> </ul> <p>You should also ensure that you have read the exercise document, linked above. Ensure you have understood all the procedures.</p>"},{"location":"#by-the-end-of-the-3rd-laboratory-session","title":"By the end of the 3<sup>rd</sup> laboratory session","text":"<p>By the end of the 3<sup>rd</sup> laboratory session, ensure that you have all exercises completed and marked.</p> <ul> <li>Basic: Encoders + Motor</li> </ul> <p>Note</p> <p>To acheive the Advanced exercises you will need to put in extra effort, outside of the laboratory sessions, to fulfil the requirements, and work to your own timeline. The above time plan will only allow you to acheive the requirements for the basic exercises.</p>"},{"location":"Assessment/","title":"Assessment","text":""},{"location":"Assessment/#assessed-exercises","title":"Assessed Exercises","text":"<p>There are 9 assessed exercises, each will build on a previous exercise. Six of these exercises are classed as \u201cBasic\u201d and we expect that all groups should be able to complete these using the three laboratory classes and maybe a little working outside the lab. These Basic exercises are worth 70% of the total assessment mark. There are also three \u201cAdvanced\u201d exercises, which are an extension to the Basic exercises, and will require extra work outside the laboratory session to complete \u2013 these are worth the final 30% of the assessment mark. </p> <p>Note</p> <p>You must complete all the Basic exercises before you can gain credit for any of the Advanced exercises.</p> <p>The marks weighting for each exercise is provided in Table 1:</p> Exercise:Weighting: Basic: LED Pattern15% Basic: Calibration of Potentiometer Angle 5% Basic: IR Sensor Measurement + Graph10% Basic: Externally Powered Servo10% Basic: DC Motor15% Basic: Encoders + Motor15% Advanced: PI Control \u2013 Encoder Position10% Advanced: PI Control \u2013 IR Sensor Distance10% Advanced: PI Control \u2013 IR with Sequence10% Total100% Marks Weighting for the Introduction to Arduino Exercises. <p>You will have three laboratory support sessions to complete these exercises, at the end of the 3rd laboratory we will stop marking. Any exercises not marked by the end of the session will not be marked. </p> <p>To complete all the Basic exercises, you will almost certainly need to do a little work outside the laboratory sessions. To complete all the Advanced exercises you will need to put in extra effort, outside the laboratory sessions, to fulfil the requirements.</p> <p>The system has been designed, such that it is a sequential development, where each exercise builds on previous exercises, both in terms of hardware and software. This way, you do need to dismantle your circuits between exercises allowing you to work more efficiently across exercises. </p> <p>Building the Robot</p> <p>When you come to build the system, you can either build it all the circuitry at the start or you can build the circuitry section by section, as you progress through the exercises. Details of the mechanical and electrical systems are provided in the Building the Robot section of this site.</p>"},{"location":"Assessment/#suggested-timeline-for-the-mandatory-exercises","title":"Suggested Timeline for the Mandatory Exercises","text":"<p> There is no rigid structure for your progress through these exercises, but the following time plan, (this is a summary of the time plan from the Introduction) should be sufficient to ensure that you have time to complete all the Basic exercises and have them marked by the GTAs before the end of the 3rd laboratory session.</p> When:What: End of session 1Robot Assembled and LED Pattern Marked Start of session 2 POT Calibration Angle Prepared End of session 2DC motor exercise completed Start of session 3Encoder circuit implemented End of session 3 (Final Session)All work completed and marked for the basic exercises Suggested timeline to complete the basic exercises, only. <p>If you are planning to complete the Advanced exercises, you will be required to achieve these goals quicker and have any Advanced exercise marked by the end of the 3rd laboratory session. Any exercises not marked by the end of the 3rd session will not be marked, and you will lose the marks for these unmarked exercises.</p> <p>Note</p> <p>You must have completed all the basic exercises before you can receive credit for any of the advanced exercises.</p>"},{"location":"Assessment/#peer-assessment","title":"Peer Assessment","text":"<p>There will be a BuddyCheck peer assessment for this section of the course, which is accessed through Blackboard. This must be completed in the deadline - details on Blackboard. Failure to complete this peer assessment within the deadline will result in a loss of 10% from your group mark, (only for the non-submitting individual).</p> <p>All peer assessments will be individually viewed, both in terms of the mark awarded and the worded comments provided. The peer assessment will only be used to penalise students that are not contributing to the group effort. We will not penalise students on peer assessment scored alone, but will use these in conjunction with the worded responses. (The worded responses hold considerably more sway in deciding if a student should be penalised for not engaging and contributing to the group activities.)</p>"},{"location":"Background/","title":"Some Useful Background Information","text":"<p>This is some background information to accompany the discussions</p>"},{"location":"Background/#analogue-sensors","title":"Analogue Sensors","text":"<p>Sensors are used in real world applications to measure physical phenomena and convert these into an electrical characteristic, as illustrated in Figure 9.</p> <p>Figure 9. Measuring Physical Phenomena with a Sensor</p> <p>Most \u2018raw\u2019 sensors do not produce a voltage on their output, but instead the output of the sensor has a modified electrical characteristic, in response to a change in the physical phenomenon being measured. Table 2, illustrates some typical examples of different sensor types used in real world applications, and the type of electrical characteristic the output of each sensor exhibits to a change in the measurement variable. </p> Phenomena: Sensor Type: Output: TemperatureThermocoupleVoltage ThermistorResistive LightPhotodiodeConductive SoundMicrophoneVoltage or Capacitive Force/PressureStrain GaugeResistive Piezoelectric TransducerCapacitive DisplacementPotentiometerResistive LVDT/ResolverAnalogue Phase/Frequency Examples of different sensor types and their output characteristics. <p>It can be seen, from Table 1, that the \u2018raw\u2019 output of most of the sensors, listed, do not exhibit a voltage output. For those sensors that have a voltage output, the output voltage is not generally of sufficient magnitude and impedance, to be sampled by the system\u2019s analogue to digital converter. As a result, signal conditioning is required to interface the vast majority sensors to a microcontroller system. </p>"},{"location":"Disclaimer/","title":"Warning and Disclaimer when using your own Laptop/MacBook","text":"<p>Warning</p>"},{"location":"Disclaimer/#warning-and-disclaimer-when-using-your-own-pcmac","title":"Warning and Disclaimer when using your own PC/Mac","text":"<p>In previous years we have had one or two incidents where student\u2019s laptops have stopped working while connected to course hardware. The exact reason for the damage is unknown, but it is suspected that a voltage spike from the servo affected the power supply/data lines on the USB interface and caused irreparable damage to the connected computer.</p> <p>Unfortunately, the SoEEE or MEE cannot accept liability for damage to personal IT systems under these circumstances. If you connect anything to your personal IT equipment, you do so at your own risk and you take responsibility for the consequences. This is especially true if you are working with circuits that you have built. It is recommended that you use the University PCs to do these activities to prevent the potential of damage to your personal equipment.</p> <p>There are a few discussions on the internet regarding this issue, one of which is:</p> <p>https://chipwired.com/can-arduino-damage-your-computer/</p> <p>It appears that a simple USB Isolator device can mostly overcome these rare occurrences. One such device is the FIT0860 Industrial USB Isolator from DFRobot:</p> <p>https://www.dfrobot.com/product-2444.html</p> <p>This device is available from numerous UK on-line suppliers for approximately \u00a320</p> <p>We will not be providing USB isolators for the Arduino activities on this module.</p> <p>Other USB Isolators range from \u00a315 to more than \u00a3200 for an industrialised device. Beware of poor imitations, they may not provide the same protection.</p> <p>There are further ways of minimizing potential damage to your home computer:</p> <ul> <li>Do not make connections to your circuit while Arduino is connected to the PC.</li> <li>Check for short circuits or incorrect connections before connecting the Arduino to the PC</li> <li>Do not power the larger servos, the DC motor or multiple SG90 servos from the power supply lines of the Arduino \u2013 you should be using the external power supply, provided.</li> <li>If using an external source, power the test circuit using the power supply and only connect the ground and signal lines to the Arduino if you are maintaining the connection to the PC.</li> <li>If you are planning to run your system from a battery pack, and not normally connected to the PC using the USB, then disconnect the wires between the battery and the Arduino before connecting the USB line. </li> </ul> <p>These methods are not a definitive answer; but should minimise a potential failure. A USB isolator device is a more robust method to minimise these potential failures.</p> <p>Just to reiterate, these occurrences are very rare, but there is a potential of problems occurring when connecting any USB device to a computer, especially if it is not a certified device, such as a circuit you have made.</p> <p>For more information regarding this issue, please speak to the  Lab Academic Lead  during the lab sessions.</p> <p>Over the years we have had many hundred students use their personal IT equipment and have only had one or two computer failures that may be due to this issue. Using a USB isolator and following the above points is the best method to protect your personal devices, when connected to an Arduino, but is not 100% guaranteed.</p> <p><p> We recommend using the University computers for these activities.</p></p>"},{"location":"RobotBuild/","title":"Building the Robot Chassis","text":""},{"location":"RobotBuild/#introduction","title":"Introduction","text":"<p>The system described in this section is the configuration that the author used during the development of the Introduction to Arduino exercises on this module, as shown in Fig 1. This configuration is the recommended configuration for the exercises during this section of the course.</p> Picture of the completed robot."},{"location":"RobotBuild/#adding-the-mechanical-components-to-the-chassis","title":"Adding the mechanical components to the chassis","text":"<p>This section will discuss the assembly of the mechanical system, and a later section will discuss the assembly of the electronic circuitry.</p> Annotated layout of the robot chassis. <p>Due to the design of the robot chassis, some elements of the robot must be constructed in order, due to overlapping parts, see Fig 2 for a diagram of the layout. The suggested order of construction is:</p> <ol> <li>Attach the yellow FIT0450 motor to the back of the chassis</li> <li>Attach the skinny wheel to the motor</li> <li>Attach the cheap plastic wheels to the front of the chassis</li> <li>Attach the MG996 servo to the front of the chassis</li> <li>Attach the IR sensor to Lolly Stick D</li> <li>Attach the lolly stick to the servo horn</li> <li>Attach the assembled lolly stick with IR sensor and servo horn to the servo shaft.</li> </ol>"},{"location":"RobotBuild/#attaching-the-fit0450-and-skinny-wheel","title":"Attaching the FIT0450 and Skinny wheel","text":"<p>This is the most awkward component to attach to the chassis. </p> <ul> <li>Push 2x M3x30 through the motor, from the brass shaft side.</li> <li>Carefully insert the motor into the chassis and manipulate it so that the screws are aligned with the screw holes in the chassis side wall.</li> <li>With a screwdriver inserted through the access holes in the chassis, push the screws through the holes and use 2x M3 nuts to fasten the motor to the chassis.</li> <li>Push the skinny wheel onto the motor shaft and use an M3x6 machine screw to fasten the wheel to the motor shaft.</li> </ul>"},{"location":"RobotBuild/#attaching-the-cheap-plastic-wheels","title":"Attaching the Cheap Plastic wheels","text":"<p>Do this Before Attaching The Servo</p> <p>These wheels must be attached before the servo, because the servo obscures access to the screw heads for the left wheel.</p> <p>The cheap plastic wheels should be attached to the lugs at the front of the chassis M4x20 machine screws. Because these wheels rotate freely, you will either need a pair of locking nuts, (the method I have used in Fig 1), or using an M4 nylon-insert lock nut \u2013 nyloc, to ensure the wheels are secure but free to rotate, as illustrated in Fig 3.</p> Fixing the cheap plastic wheels using nyloc nuts."},{"location":"RobotBuild/#attaching-the-mg996-servo","title":"Attaching the MG996 Servo","text":"<p>Do this After You Have Attached Both of the Wheels</p> <p>The MG996 servo is attached to the robot chassis using 3x M4x12 screws and 1x M4x6 screw, as illustrated in Figure 3. The shorter M4x6 screw is required to ensure that breadboard 2, see Fig 4, will fit into the chassis. If you use an M4x12 screw in this location, the tail of the screw is too long and breadboard 2 will not fit into the space provided in the chassis. Figure 3 illustrates which of the 4 M4 screws should be the M4x6.</p> Fixing screws for the MG996 Servo."},{"location":"RobotBuild/#assembling-the-lolly-stick-d-assembly","title":"Assembling the Lolly Stick D Assembly","text":"<p>The lolly stick assembly comprises of the Sharp IR sensor, a laser cut plywood linkage and a servo horn for the MG996, as shown in Fig 4.</p> Fixing Screws for the Lolly Stick Assembly. <p>It is recommended that you assemble the lolly stick assembly as shown in Fig 5, because this results in the header terminals for the IR sensor being on the top side of the IR sensor, when the lolly stick is in the horizontal position, see Fig 6.</p> <p>The IR sensor is fixed to the lolly stick with 2x M3x6 screws and 2x M3 nuts, as can be seen in Fig 5.</p> <p>The servo horn is attached to the lolly stick using 2x M2x8mm Phillips Head Flange Screws. </p> <p>Warning: Sharp Screws</p> <p>The sharp ends of the Flange screws will protrude through the opposite side of the servo horn. Please be careful while handling this assembly to prevent causing minor injury on the protruding screws.</p>"},{"location":"RobotBuild/#attaching-the-lolly-stick-d-assembly-to-the-servo","title":"Attaching the Lolly Stick D Assembly to the Servo","text":"<p>The servo horn pushes onto the servo MG996 servo shaft, then a M3x6 screw is used to fix it into position. Once attached, ensure the servo can rotate between horizontal and vertical, see Fig 6.</p> <p>Info</p> <p>This assembly will require repositioning at the start of the control of the standard servo exercise to ensure that the position is set correctly for the exercise.</p> Pictures of the lolly stick assembly attached to the servo, rotated into the horizontal and vertical positions."},{"location":"RobotBuild/#electronic-component-layout-and-connections","title":"Electronic Component Layout and Connections","text":"<p>The layout of the electronic components on the breadboard is entirely up to you, but following sections illustrate how they were laid out during the design and prototyping stages of these exercises. The author recommends following this layout because it also follows the example code provided for the exercises, and it is a tried and tested layout.</p> <p>The connections for each exercise are discussed in more detail in the following sections, but these subsections provide a bit of high level detail concerning the component placement and the DC power socket.</p>"},{"location":"RobotBuild/#breadboard-layouts","title":"Breadboard layouts","text":"<p>We suggest that the components should be placed on the two breadboards, as shown in Fig 7, with each breadboard containing:</p> <ul> <li>Breadboard 1: the LEDs, button and the motor driver board. </li> <li>Breadboard 2: the DC power inlet socket, 10K potentiometer and a 12-way header strip, used to connect the motor power and encoder, MG996 servo and the Sharp IR sensor. </li> </ul> <p>The location of breadboard 1 and breadboard 2 in the robot chassis is illustrated in Fig 2 and shown in the Fig 1.</p> Component positioning for (a) breadboard 1 and (b) breadboard 2. <p></p>"},{"location":"RobotBuild/#external-dc-power-socket-and-connection","title":"External DC Power Socket and Connection","text":"<p>Some of the robot systems draw too much power to be supplied directly from the Arduino, via the USB link. If you were to were to power the MG996 Servo or the DC motor from the Arduino, then you may pull too much power from the +5V rail and experience erratic behaviour due to the Arduino intermittently restarting \u2013 this is referred to as a brownout restart. To overcome this problem, we will use an additional external DC power supply to provide extra current capability for some of the components \u2013 MG966 servos and DC motor driver board. To facilitate this, you will add a DC power connector to your robot system, shown in Fig 8.</p> Annotated picture of the external power supply connector pins. <p>In previous years, we have had problems with the DC power connector slipping out of the breadboard. To significantly reduce the chances of this, a cable tie can be used strap the dc connector down to breadboard 2, as illustrated in Fig 9.</p> Photograph of the cable tie used to hold the DC power connector and the  positioning of the DC power connector on the breadboard. <p>Note</p> <p>Ensure that the cable tie is tight around the board and the connector will not move, before snipping the loose end.</p> <p>The following section provides important details concerning the two different power supplies on the breadboards, and MUST be read before continuing.</p>"},{"location":"RobotBuild/#arduino-and-external-power-supplies-lines","title":"Arduino and External Power Supplies Lines","text":"<p>There are two +5V power supplies on the robot chassis:</p> <ol> <li>The +5V supply from the Arduino</li> <li>The external +5V from the AC-DC Plug-in Power Supply.</li> </ol> <p>UNDER NO CIRCUMSTANCE should the +5V lines of these power supplied be connected together. You must, however, connect all the GND lines of these power supplies, and other systems, to a common GND net/node on your robot chassis to ensure that all the working from the same reference voltage.</p> <p>The external +5V should only be connected to the V<sub>m</sub> connection of the motor drive board and the V+ power connections of any servo used on your system. The Arduino +5V should be used for the V<sub>cc</sub> connection of the motor drive board and any other connection requiring +5V, which is not connected to the external +5V.</p> <p>Danger: You can destroy your Laptop motherboard if you get this wrong</p> <p>If you connect the +5V supply of the Arduino and the external power supply together you risk destroying the motherboard of your laptop by sending a voltage spike up the USB lead when the servo or the DC motor operate.</p> <p>Read the Disclaimer document before proceeding.</p> <p>The University and MEE take no responsibility for damaged laptops due to this issue. We recommend using the University IT equipment to mitigate damaging your personal equipment.</p> <p>At this point you may have noticed that we don't want you to connect the external +5V to the Arduino +5V. This is because we don't want to tell any other student that we will not be paying for repairs to their personal IT equipment... It is not a fun conversation to have!</p>"},{"location":"RobotBuild/#suggested-circuit-layouts-for-the-exercises","title":"Suggested Circuit Layouts for the Exercises","text":"<p> The electronic system for the robot can be incrementally built as required for the exercise you are working on. The exercises are designed, such that, you only need to add components to the system, with the later exercises build on the previous. This means that no circuitry needs to be removed between exercises.</p> <p>Before you start any of the following exercises, you will need to add extra elements into your robot circuit.</p> <ol> <li>Basic: LED Pattern<ul> <li>No extra circuitry is required for the Calibration of Potentiometer Angle Exercise. This uses the potentiometer from the LED Pattern Exercise.</li> </ul> </li> <li>Basic: IR Sensor Measurement + Graph</li> <li>Basic: Externally Powered Servo</li> <li>Basic: DC Motor</li> <li>Basic: Encoders and Motor</li> </ol> <p>Note: Advanced Exercises</p> <p>The advanced exercises do not require any extra circuit build. They work from the circuit that has been constructed for the final Basic Exercise: Encoders and Motor.</p>"},{"location":"RobotBuild/#circuit-layout-for-the-led-pattern-and-calibration-of-potentiometer-angle-exercises","title":"Circuit Layout for the LED Pattern and Calibration of Potentiometer Angle Exercises","text":"<p>The following circuit layout is sufficient to complete both the LED pattern and the Calibration of Potentiometer Angle Exercises. This section illustrates where to layout and the connections for: the three LEDs and associated resistors, the button and the potentiometer, as illustrated in Fig. 10.</p> Diagram showing the suggested component layout and wiring for the LED Pattern Exercise. <p>The extra components list required for this exercise, shown in Fig. 10, other than the Arduino and 2x breadboards:</p> <ul> <li>3x LED</li> <li>3x 470\u03a9 resistor</li> <li>Tactile button</li> <li>100nF capacitor</li> <li>Potentiometer</li> <li>12-way header</li> </ul> <p>Fig. 10 illustrates the component layout, but for clarity, Table 1 lists the connections into the Arduino that we recommend for this section:</p> Arduino Pin: Description: DIO 4Button DIO 11LED 1 DIO 12LED 2 DIO 13LED 3 A5Potentiometer Input Suggested Connection table for the LED Pattern Exercise. <p>This circuit layout can be used for the LED pattern and the Calibration of Potentiometer Angle exercises.</p> <p></p>"},{"location":"RobotBuild/#circuit-layout-for-the-ir-sensor-exercise","title":"Circuit Layout for the IR Sensor Exercise","text":"<p>This section illustrates the connection of the Sharp IR sensor into the circuit, required for the IR Sensor Measurement and Graph exercise, as illustrated in Fig. 11. You should keep the circuit wired from the previous section.</p> Diagram showing the suggested component layout and wiring for the IR Sensor Exercise. <p>Extra parts required for this configuration:</p> <ul> <li>Sharp IR Sensor</li> <li>Sharp IR Sensor cable</li> </ul> <p>Table 2 lists the connections into the Arduino that we recommend for the IR Sensor:</p> Arduino Pin: Description: A4IR Sensor Output Suggested Connection Table for the LED Pattern Exercise. <p>The Sharp IR sensor cable has header connections attached to the non-sensor end. The header connections should plug into the 12-way header on the breadboard, in the place illustrated in Fig. 11.</p>"},{"location":"RobotBuild/#circuit-layout-for-the-externally-powered-servo-exercise","title":"Circuit Layout for the Externally Powered Servo Exercise","text":"<p>The servo will be used in the Driving a Servo Motor Exercise. Fig. 12 illustrates the connections required for the servo and the external DC power socket. You should keep the circuit wired from the previous section.</p> <p>Warning</p> <p>UNDER NO CIRCUMSTANCE should the +5V External power supply be connected to the +5V Arduino supply. You must, however, connect all the GND lines of these power supplies, and other systems, to a common GND net/node on your robot chassis to ensure that all the working from the same reference voltage.</p> <p></p> Diagram showing the suggested component layout and wiring for the Externally Powered Servo Exercise. <p>The extra components list required for this exercise, shown in Fig. 12, other than the Arduino and 2x breadboards:</p> <ul> <li>DC Servo</li> <li>DC power socket (SG90 for the initial servo exercise and final assessed Exercise)</li> </ul> <p>Note</p> <p>The initial servo exercise used the MG90 powered from the Arduino +5V supply, not the external 5V supply. You may wish to consider this when building your circuit.</p> <p>Table 3 lists the connections into the Arduino that we recommend for the servo exercise:</p> Arduino Pin: Description: DIO 6Servomotor Signal Pin Suggested Connection Table for the Servomotor. <p></p>"},{"location":"RobotBuild/#circuit-layout-for-the-dc-motor-exercise","title":"Circuit Layout for the DC Motor Exercise","text":"<p>The DC motor exercise requires both the TB6612FG and the DC motor to be wired into the circuit, as illustrated in Fig. 13. During this section you will only be wiring the power connections to the motor, and not the encoder signals. You should keep the circuit wired from the previous section.</p> Diagram showing the suggested component layout and wiring for the DC Motor Exercise. <p>Extra parts required for this configuration:</p> <ul> <li>TB6612FG driver board</li> <li>DC motor</li> <li>DC motor power cable</li> </ul> <p>Due to the most convenient orientation of the TB6612FG motor driver board on the robot, we will be using channel B for these exercises. The TB6612FG driver board is shown in Fig 14.</p> Picture of the TB6612FG motor driver board, with pins labelled. <p>Table 4 lists the connections into the Arduino that we recommend for the DC motor exercise:</p> Arduino Pin: Description: DIO 5PWM Signal Pin DIO 8BI1 Signal Pin DIO 7BI2 Signal Pin Suggested Connection Table for the DC Motor. <p>Note</p> <p>All the GND connections are internally connected on the TB6612FG breakout board, therefore, only one GND connection is needed to the power system.</p> Pin:Description:Connected to: VmMotor Power System SupplyExternal +5V VccLogic Control Power SupplyArduino +5V GNDGroundN/C AO1Channel A Motor Output 1N/C AO2Channel A Motor Output 2N/C BO2Channel B Motor Output 2Motor - BO1Channel B Motor Output 1Motor + GNDGround PWMAChannel A PWM SignalN/C AI2Channel A Bridge Configuration Input 2N/C AI1Channel A Bridge Configuration Input 1N/C StandbyDriver Chip Standby SignalArduino +5V BI1Channel B Bridge Configuration Input 1Arduino DIO 8 BI2Channel B Bridge Configuration Input 2Arduino DIO 7 PWMBChannel B PWM SignalArduino DIO 5 GNDGroundPower Supply GND Pin connections to the TB6612FG motor driver board. <p>The DC motor power is connected through the 12-way header, as shown in Fig. 13. The connections for the driver board are shown in Table 5. </p> <p></p>"},{"location":"RobotBuild/#circuit-layout-for-the-encoders-and-motor-exercise","title":"Circuit Layout for the Encoders and Motor Exercise","text":"<p>The final part of the circuit to connect is the motor encoder to the Arduino, as illustrated in Fig. 15. The encoder is connected through the 12-way header, as shown in Fig. 15.</p> Diagram showing the suggested component layout and wiring for the Encoders and Motor Exercise. <p>Extra parts required for this configuration:</p> <ul> <li>DC motor encoder cable</li> </ul> <p>Table 4 lists the connections into the Arduino that we recommend for the DC motor exercise:</p> Arduino Pin: Description: DIO 2Encoder B Signal DIO 3Encoder A Signal Suggested Connection Table for the Rotary Encoder."},{"location":"RobotBuild/#the-12-way-header-connections","title":"The 12-Way Header Connections","text":"<p> The 12-way header connector provides a convenient method for interfacing some of the system components: motor, encoder, servo and, IR sensor, to the breadboard for easy connection to the remaining electrical system. A summary of the connections used in development are provided in Table 7.</p> Pin:Description:Connected to: 1Motor +Driver Board BO1 2Motor -Driver Board BO2 3Encoder A SignalArduino DIO 3 4Encoder B SignalArduino DIO 2 5Encoder GNDGND 6Encoder +5VArduino +5V 7Servo SignalArduino DIO 6 8Servo +5VExternal +5V 9Servo GNDGND 10IR Sensor +5VArduino +5V 11IR Sensor GNDGND 12IR Sensor SignalArduino Analogue Input A4 12-Way Header Connections to robot components."},{"location":"AdvancedExercises/","title":"Introduction","text":"<p>Read This Before Attempting These Exercises</p> <p>Before starting these exercises, you should have completed all the basic exercises. You will not receive any credit for completing these Advanced exercises until you have had all the Basec exercises marked.</p> <p>These advanced exercises more concerned with the integration of the interfacing concepts that you have worked on in the Basic Exercises into a more complex system.</p> <p>As discussed in the Introduction document, There are three advanced exercises for this activity:</p> <ul> <li>Advanced: PI Control \u2013 IR Sensor Distance: During this exercise you, will use the IR distance sensor as a feedback element to implement a PI controlled distance tracking system with your robot.</li> <li>Advanced: PI Control \u2013 Encoder Position: during this exercise, you will implement a PI controller to track a position command, and use a finite state machine to control the system reference.</li> <li>Advanced: PI Control \u2013 IR with Sequence: During this exercise, you will use all the elements of the Basic and previous Advanced exercises to implement a sequences control system for your robot.</li> </ul> <p>Note</p> <p>To gain credit for these Advanced exercises, you must have completed, and have had marked, all the Basic Exercises before we will mark the advances exercises.</p> <p>The Timeline we present in the Activity Introduction does not include these advanced exercises, to you will put in extra effort, outside the laboratory sessions, to complete these exercises.</p> <p>Each of these exercises will be assessed during the laboratory session, using the assessment structure outlined in the The Assessment document. When you have completed an assessed exercise, you should get your work marked one of the GTAs. </p> <p>Warning</p> <p>DO NOT leave all your exercises until the end of the 3rd laboratory session to get marked. This may result in you running out of time to get your work marked within the allotted time, and you will lose marks. Instead, you should get your work marked as you complete each assessed exercise.</p>"},{"location":"AdvancedExercises/Ex7PiIrDist/","title":"Calibrate Potentiometer Angle","text":"<p>GTA Marking</p> <p>This is an assessed Exercise. When you have completed the Assessed Exercise, you should show your work to a GTA to get marked.</p> <p>Before Continuing</p> <p>Before starting these exercises, you should ensure that you have completed all the Basic Exercises and have fully constructed the robot chassis, as described in the Building the Robot document.</p> <p>The following video is a quick demonstration of the final outcome from this exercise:</p> Video demonstrating the expected outcome from this exercise"},{"location":"AdvancedExercises/Ex7PiIrDist/#introduction","title":"Introduction","text":""},{"location":"AdvancedExercises/Ex7PiIrDist/#pi-controller-implementation","title":"PI controller implementation","text":""},{"location":"AdvancedExercises/Ex7PiIrDist/#a-note-on-code-timing-and-determinacy-for-embedded-systems","title":"A note on code timing and determinacy for embedded systems","text":"<p>When implementing a PI controller on an embedded system, it is important to maintain strict timing of the algorithm, to ensure that you are reading the inputs and sensors, and processing the controller algorithm at known times, normally at specific time intervals. Maintaining strict and consistent timing for these ensures that the algorithms you are using function as expected and produce predictable behaviour.</p> <p>Using <code>delay()</code> functions within your code often leads to code that does not have consistent timing, and it is often difficult to predict the code execution time for sections of code.</p> <p>To maintain more consistent code timing, the millisecond tick timer, called using the <code>millis()</code> function, should be used to constrain the timing of your code. This is more consistent with the real-time programming requirements of embedded system control and can significantly improve the determinacy of your code. </p> <p></p>"},{"location":"AdvancedExercises/Ex7PiIrDist/#assessed-exercise","title":"Assessed Exercise","text":""},{"location":"BasicExercises/","title":"Introduction to the Basic Exercises","text":"<p>The assessed exercises are split into sections:</p> <ol> <li>Basic Exercises: These are more concerned with the fundamentals of getting a specific interface, sensor, or actuator operating.</li> <li>Advanced Exercises: These are more concerned with integrating the elements of the Basic Exercises into a working system, to achieve a goal. During the Advanced exercises you will also work with slightly more advanced programming concepts, such as implementation of a PI Controller and simple finite state machines, (we will provide programming templates for both of these topics).</li> </ol> <p>As discussed in the Introduction document, This activity is split into several assessed exercises. This section describes the Basic Exercises, as follows:</p> <ul> <li>Basic: LED Pattern</li> <li>Basic: Calibration of Potentiometer Angle</li> <li>Basic: IR Sensor Measurement + Graph</li> <li>Basic: Externally Powered Servo</li> <li>Basic: DC Motor</li> <li>Basic: Encoders + Motor</li> </ul> <p>You must complete, and have had marked, all of these exercises before you can gain credit for the Advanced Exercises.</p> <p>A suggested timeline for achieving only the basic exercises is provided in the introductory document.</p> <p>Each of these exercises will be assessed during the laboratory session, using the assessment structure outlined in the Appendix section of this document. When you have completed an assessed exercise, you should get your work marked one of the GTAs. </p> <p>Warning</p> <p>DO NOT leave all your exercises until the end of the 3rd laboratory session to get marked. This may result in you running out of time to get your work marked within the allotted time, and you will lose marks. Instead, you should get your work marked as you complete each assessed exercise.</p>"},{"location":"BasicExercises/Ex1ledPattern/","title":"LED Pattern","text":""},{"location":"BasicExercises/Ex1ledPattern/#introduction","title":"Introduction","text":"<p>During the LED Pattern exercise you will generate a repeating sequence on 3 LEDs, use a potentiometer to change the cycle rate of the sequence, and use a push button to pause the sequence.</p> <p>GTA Marking</p> <p>This is an assessed Exercise. When you have completed part 3, you should show your work to a GTA to get marked.</p> <p>Note</p> <p>Before starting these exercises, you should ensure that you have added the LEDs, the button and the potentiometer to the breadboards on the robot chassis, as suggested on Building the Robot: Fig. 6. Furthermore, you should ensure that your connections for these components are correct - suggested connections are shown in Building the Robot: Building the Robot: Table. 1.</p> <p>The following video is a quick demonstration of the final outcome from this exercise:</p> Video demonstrating the expected outcome from this exercise"},{"location":"BasicExercises/Ex1ledPattern/#part-1-led-sequence","title":"Part 1: LED Sequence","text":"<p> During this part, you will write a program to create a repeating sequence of LEDs, with a fixed sequence time step, e.g. say every \u00bd second. A suggested LED sequence is shown in Table. 1. </p> Sequence Index: LED 3 (DIO 13) LED 2 (DIO 12): LED 1 (DIO 11): 0000 1001 2010 3011 4100 5101 6110 7111 Suggested simple repeating sequence, (counting-up in binary). <p>We will not provide any example code to facilitate this exercise, you must create this code from scratch, possibly using some of the example code provided in the Introductory Exercises or the built-in examples as inspiration.</p> <p>Procedure:</p> <ol> <li>Ensure that the circuit is correctly connected:<ul> <li>We suggest the anode of the LED be connected to Arduino pins DIO11 to 13.</li> <li>Each of the cathodes of the LEDs should be connected through a 470\u03a9 resistor to ground.</li> </ul> </li> <li>Write a program to change the pattern of the LEDs at a fixed rate, say every \u00bd second, and loop through the sequence continuously. We suggest using the sequence from Table 1.</li> <li>If you do not use the sequence provided in Table 1, your sequence should have at least 8 patterns, some but not most may repeat.</li> <li>For this we suggest using a delay function to control the timing of the sequence. The rationale for this is that we will replace the bracket value on the <code>delay()</code> function with the ADC read value, to control the speed of the sequence. </li> <li>Ensure that you save your code when you have completed this part.</li> </ol> <p>Note</p> <p>We strongly recommend using the suggested connection and layout provided in Building the Robot Document because it will link conveniently with the discussions and the example code provided. Using the suggested layout and connections also makes debugging your work easier because you will have a more familiar structure for the staff and GTAs.</p>"},{"location":"BasicExercises/Ex1ledPattern/#part-2-potentiometer-control-of-the-sequence-rate","title":"Part 2: Potentiometer Control of the Sequence Rate","text":"<p>Info</p> <p>It is suggested in the Building the Robot Document that your potentiometer is connected to analogue pin A5.</p> <p>This part of the exercise is split into two sub sections:</p> <ol> <li>Using the POT.ino test program to read the potentiometer value and display it on the serial monitor.</li> <li>Modifying the LED sequence code so that the potentiometer value is used to control the pattern change rate of the LED sequence.</li> </ol>"},{"location":"BasicExercises/Ex1ledPattern/#section-1-the-read-the-potentiometer-test-program-potino","title":"Section 1: The Read the Potentiometer Test Program, POT.ino","text":"<p>The aim of the POT.ino example code is to show you how to read an analogue value from a sensor, or other device, and use its value. In this example code you will read the voltage from a potentiometer, generate a PWM output to change the brightness of an LED, and stream some data to the Serial Monitor. </p> <p>Procedure:</p> <ol> <li>Copy the POT.ino code into a black Arduino sketch and save it into your working folder.</li> <li>Ensure the LEDs and potentiometer are connected into your circuit, as described in the Building the Robot Document</li> <li>Ensure the potentiometer is connected into the circuit.<ul> <li>Connect left hand pin of the potentiometer to GND and the 5V and the right hand pin to +5V.</li> <li>It is suggested that the middle pin of the potentiometer is connected to the analogue A5 pin.</li> </ul> </li> </ol> <p>The analogue to digital converter, ADC, inputs to the Arduino have 10 bits of resolution (i.e. 1024 different values). By default, they measure from ground (0V) to 5 volts. That means that the 0-5V range of the potentiometer will be proportionally mapped to the 0-1023 digital values range in the microcontroller. </p> <ol> <li>Upload the program to the Arduino, then open the serial monitor and observe data being streamed to the terminal.</li> <li>Rotate the knob of the potentiometer and observe the range that the data spans.</li> <li>Observe the rightness of the LED as you rotate the potentiometer.</li> <li>Ensure that you save your code when you have completed this section.</li> </ol> <p>This example program uses the map() function to \u2018map\u2019 the ADC measurement values between 0 and 1023, to a range of 0 to 255. This new range is required to write the PWM signal to change the LED brightness \u2013 PWM will be covered in the next lab session, so for this example, just assume this is an analogue output from the Arduino.</p> <p>Look at the code and see how the map() command is used. The Arduino language reference for the map command can be found at:</p> <p>https://www.arduino.cc/reference/en/language/functions/math/map/ </p>"},{"location":"BasicExercises/Ex1ledPattern/#section-2-integrate-the-potentiometer-value-into-your-led-sequence-program","title":"Section 2: Integrate the Potentiometer Value Into Your LED Sequence Program","text":"<p>During this section you will integrate the reading of the potentiometer into the program for your LED sequence, and use the ADC value to control the delay function in the main loop.</p> <p>Procedure:</p> <ol> <li>Starting with the code you wrote in Part 1, modify your code to read the voltage value of the potentiometer, using the ADC, each time the sequence value changes.</li> <li>The ADC value should be used to control the <code>delay()</code> function time within the sequence loop.</li> <li>Ensure that you save your code when you have completed this section.</li> </ol> <p>When you rotate the potentiometer to the right, the sequence should speed up, and when you rotate the potentiometer to the left, the sequence should slow down. There should be a continuous variation in sequence speed proportional to the position of the potentiometer between the left and right extremes.</p>"},{"location":"BasicExercises/Ex1ledPattern/#part-3-addition-of-a-pause-button","title":"Part 3: Addition of a Pause Button","text":"<p>During this part, you will implement the reading of the button on breadboard 1 and use the button value to pause the execution of the sequence.</p> <p>Procedure:</p> <ol> <li>Starting from your code that you completed in Part 2, section 2, implement a button read from the button on breadboard 1.</li> <li>Use this the pressed value of the button to hold the flow of execution until the button is released. </li> </ol> <p>When completed, your code should function as follows:</p> <ul> <li>The three LEDs should be flashing in a continuously repeating sequence of at lease 8 different patterns.</li> <li>When you rotate the potentiometer to the right, the sequence should speed up, and when you rotate the potentiometer to the left, the sequence should slow down. There should be a continuous variation in sequence speed proportional to the position of the potentiometer between the left and right extremes.</li> <li>When the button is pressed, the sequence should pause, but not reset.</li> </ul> <p>Now Get Your Work Marked by a GTA</p> <p>Once you have completed your code and are satisfied with its operation, you should show your work to a GTA for marking.</p>"},{"location":"BasicExercises/Ex1ledPattern/#appendix-potino-code","title":"Appendix: POT.INO Code","text":"POT.ino Arduino Code<pre><code>// Global Name Space\nint potAnalogPin = 0; // FSR is connected to analog 0\nint LEDpin = 11;      // connect Red LED to pin 11 (PWM pin)\nint potReading;      // the analog reading from the FSR resistor divider\nint LEDbrightness;\n\nvoid setup(void) {\n  // We'll send debugging information via the serial monitor\n  Serial.begin(9600);   \n  pinMode(LEDpin, OUTPUT);\n}\n\nvoid loop(void) {\n  potReading = analogRead(potAnalogPin);\n  Serial.print(\"Analog reading = \");\n  Serial.println(potReading);\n\n  // we'll need to change the range from the analog reading (0-1023) down to\n  //the range used by analogWrite (0-255) with map!\n  LEDbrightness = map(potReading*1, 0, 1023, 0, 255);\n\n  // LED gets brighter the harder you press\n  analogWrite(LEDpin, LEDbrightness); // here you are using PWM !!!\n\n  delay(10);\n}\n</code></pre>"},{"location":"BasicExercises/Ex2PotCalibration/","title":"Calibrate Potentiometer Angle","text":"<p>GTA Marking</p> <p>This is an assessed Exercise. When you have completed the Assessed Exercise, you should show your work to a GTA to get marked.</p> <p>Before Continuing</p> <p>Before starting these exercises, you should ensure that you have completed the LED Pattern exercise and have the potentiometer and LED still connected. </p> <p>The following video is a quick demonstration of the final outcome from this exercise:</p> Video demonstrating the expected outcome from this exercise"},{"location":"BasicExercises/Ex2PotCalibration/#introduction","title":"Introduction","text":"<p>The Aim of this exercise is to convert the ADC measurement value of the potentiometer voltage into an angle measurement, in degrees. The starting point for this exercise is the layout provided in Building the Robot Document and the POT.ino example code provided at the end of LED Pattern Exercise</p> <p></p>"},{"location":"BasicExercises/Ex2PotCalibration/#assessed-exercise","title":"Assessed Exercise","text":"<p>The map function can be used to provide a linear calibration between a measured value and a real world parameter. In this exercise, you will use the ADC measurement value as the input to a <code>map()</code> function and use it to calculate the potentiometer angle.</p> <p><code>map()</code> function</p> <p>See the <code>map()</code> function page from the Arduino language reference pages for a description: https://docs.arduino.cc/language-reference/en/functions/math/map/</p> <p>Procedure:</p> <ol> <li>The starting point for this exercise is the Potentiometer test program, POT.ini, from the previous exercise and the LED pattern circuit from the Building the Robot Document.</li> <li>Add a <code>map()</code> function to the sketch to calibrate the potentiometer angle between -150 and 150 for an ADC measurement input of 0 to 1023.</li> <li>Using the <code>Serial.print()</code> and <code>Serial.println()</code> functions, (similar to that shown in POT.ino), write the data to the serial monitor with appropriate description.</li> </ol> <p>Serial Communication Functions</p> <p>See the serial communications functions page from the Arduino language reference pages for a description of the <code>Serial.print()</code> and <code>Serial.println()</code> functions: https://www.arduino.cc/reference/en/language/functions/communication/serial/</p> <p>When completed, your code should function as follows:</p> <ul> <li>When you rotate the potentiometer, the serial monitor should display the ADC read value and the potentiometer angle, in degrees.</li> <li>The serial monitor messages should provide a brief, (a word or 3), description of the variables printed and should be well formatted.</li> <li>The serial monitor should update at a reasonable rate \u2013 2 to 4 times a second.</li> </ul> <p>Now Get Your Work Marked by a GTA</p> <p>Once you have completed your code and are satisfied with its operation, you should show your work to a GTA for marking.</p>"},{"location":"BasicExercises/Ex3IrSensor/","title":"Measure the Output of the Sharp IR Distance Sensor","text":"<p>GTA Marking</p> <p>This is an assessed Exercise. When you have completed the Assessed Exercise, you should show your work to a GTA to get marked.</p> <p>Note</p> <p>Before starting these exercises, you should ensure that you have completed the circuit on the robot chassis, as suggested on Building the Robot: Fig. 11. Furthermore, you should ensure that all the connections described in the Building the Robot: Circuit Layout for the IR Sensor Exercise are correct.</p> <p>The following video is a quick demonstration of the final outcome from this exercise:</p> Video demonstrating the expected outcome from this exercise"},{"location":"BasicExercises/Ex3IrSensor/#introduction-and-background","title":"Introduction and Background","text":"<p>The aim of this exercise is to generate a graph of sensor measurement from the Sharp IR distance sensor against measurement distance. During this exercise, you will interface the Sharp IR distance sensor with the Arduino, record the measured voltage as a function of the distance to a target, and observe any constraints for the operation of this sensor.</p> <p>Before you start this exercise, you will need to construct the circuit according to the IR sensor circuit instructions in the Building the Robot Document.</p>"},{"location":"BasicExercises/Ex3IrSensor/#noise-on-the-ir-sensor","title":"Noise on the IR sensor","text":"<p>The IR sensor is not an ideal sensor and induces noise onto the output of the sensor, as shown in Fig 1.</p> Serial Plotter Showing Noise on the IR distance sensor. <p>A simple moving averaging filter technique can be used on the data to reduce the noise content of the signal. A simple, but effective, implementation of this technique is shown in the Averaging Code, below:</p> <p>Averaging Code<pre><code>//Read the IR sensor\nirVal = analogRead(irPin);\n\n// accumulate a further 7 readings\nirVal = irVal + analogRead(irPin);\nirVal = irVal + analogRead(irPin);\nirVal = irVal + analogRead(irPin);\nirVal = irVal + analogRead(irPin);\nirVal = irVal + analogRead(irPin);\nirVal = irVal + analogRead(irPin);\nirVal = irVal + analogRead(irPin);\n\n// right shift 3 places to divide by 8\nirVal = irVal &gt;&gt; 3;\n</code></pre> The Averaging Code, above, sums the result of 8 ADC readings of the IR sensor and take the average value of these readings. This is a crude, but effective method for noise reduction, in this instance. The results of this implementation can be seen from the data shown in Fig 2.</p> Serial Plotter Showing the Averaged IR Sensor Data. <p>Camparing the magnitude of the noise on the IR sensor measurement, between Fig 1 and Fig 2 it can be seen that this averaging technique has significantly reduced the sensor noise. </p>"},{"location":"BasicExercises/Ex3IrSensor/#experimental-setup-with-lolly-stick-up","title":"Experimental Setup with Lolly Stick up","text":"<p>The IR sensor is sensitive to picking up reflections from any surface that it is operating. It has been found from experimentation, that raising the sensor above the surface that it is operating produces improved and more consistant results.</p> <p>As a result, when using the IR sensor, you should ensure that the lolly stick assembly is in the upright position, as shown in the righthand figure in the Building the Robot document</p> <p>For more details on concerning the pin connections for the Sharp GP2Y0A21YK0F distance measurement sensor, see the data sheet for the sensor on the Blackboard site:</p> <ul> <li>ACS231 Blackboards Site&gt;&gt;Mechatronics Kit Information&gt;&gt; Component Data Sheets and Technical Documentation.</li> </ul>"},{"location":"BasicExercises/Ex3IrSensor/#expected-results","title":"Expected Results","text":"<p>The IR sensor has a non-linear distance to output voltage characteristic, as illustrated in Fig 3. This graph has been provided as an example characteristic for how your data should come out...except that your results should have a y-axis scale!</p> Characteristic measurement result from the IR distance sensor. <p></p>"},{"location":"BasicExercises/Ex3IrSensor/#assessed-exercise","title":"Assessed Exercise","text":"<p>For this exercise you will write an Arduino sketch to measure the output of the IR sensor and display its value of on the serial monitor. The distance measurements should be taken at static positions, using a series of measurement points similar to:</p> <p>1cm, 2cm, 3cm, 4cm, 5cm, 6cm, 7cm, 8cm, 9cm, 10cm, 15cm, 20cm, 25cm, 30cm, 35cm, 40cm, 45cm, 50cm, 55cm, 60cm, 65cm, 70cm, 75cm, and 80cm</p> <p>You should plot your results in a computer package, such as Excel or MATLAB, with the x-axis as the distance measured, and the y-axis as the ADC measurement value. </p> <p>Procedure:</p> <ol> <li> The starting point for this exercise is the circuit layout for the IR sensor and the potentiometer code, POT.ini located at the end of the LED pattern exercise.</li> <li> Write an Arduino sketch to read the analogue measurement value from the IR distance sensor and display the reading on the serial monitor. (It is acceptable to use a fresh copy of the POT.ini as a template for this exercise.)</li> </ol> <p>Once you have the measured value of the distance sensor being streamed to the serial monitor, you will be required to plot the distance sensor measurement value against distance measured, (with a ruler/scale).</p> <ol> <li> Perform an experiment to characterise the Sharp IR sensor between 1cm and 80cm distance. The results from this experiment should be a graph of the ADC measurement value from the Sharp IR distance sensor, against the distance from the target. Note: Your graph should have a similar characteristic to that shown in Fig 3.</li> </ol> <p>When completed, your code should allow you to run an experiment to draw the following graph:</p> <ul> <li>A graph of ADC measurement value against distance.</li> <li>The trace should be correctly framed within the axes.</li> <li>Appropriate axes labels, with units and a descriptive graph title. You should plot your results in a computer package, such as Excel or MATLAB, with the x-axis as the distance measured, and the y-axis as the ADC measurement value, as illustrated in Fig 3</li> </ul> <p>Now Get Your Work Marked by a GTA</p> <p>Once you have completed your code and are satisfied with its operation, you should show your work to a GTA for marking.</p>"},{"location":"BasicExercises/Ex4DriveServoMotor/","title":"Driving a Servo Motor","text":"<p>GTA Marking</p> <p>This is an assessed Exercise. When you have completed the Assessed Exercise, you should show your work to a GTA to get marked.</p> <p>Note</p> <p>Before starting these exercises, you should ensure that you have completed the circuit on the robot chassis, as suggested on Building the Robot: Fig. 12. Furthermore, you should ensure that all the connections described in the Building the Robot: Circuit Layout for the Externally Powered Servo Exercise are correct.</p> <p>The following video is a quick demonstration of the final outcome from this exercise:</p> Video demonstrating the expected outcome from this exercise"},{"location":"BasicExercises/Ex4DriveServoMotor/#introduction","title":"Introduction","text":"<p>The aim of this exercise is to demonstrate the control of a position control servo, in this case the MG90 servomotor. The MG90 is a very low power servo motor and can be driven directly from the Arduino board power supply.</p>"},{"location":"BasicExercises/Ex4DriveServoMotor/#controlling-a-standard-servomotor-directly-from-the-arduino-informal-exercise","title":"Controlling a Standard Servomotor directly from the Arduino. (Informal Exercise)","text":"<p>Transitioning to MG90 Servo Motors</p> <p>We are transitioning away from SG90 servos due to robustness issues and replacing these with MG90 servos. Some of you may still find that you have an SG90 servo in your kit \u2013 this is OK, you can use this device with same wiring, fixtures, and code.</p> <p>The MG90 is a very low power servo motor and can be driven directly from the Arduino board power supply, without the need for an external supply. If you attempt this with the MG996 servo, you may find that the current draw is too great, and this may cause glitches in the power supply lines that cause the Arduino to \"Brownout reset\u201d. For the remainder of this exercise, we will use the MG90.</p> <p>Note on the following Informal Exercise</p> <p>The exercise is a legacy exercise from a previous iteration of this course and required an unconnected Arduino and a MG90 servo, i.e. not connected into your robot chassis, as shown in Fig. 1.</p> <p>This exercise is not manditory, but provides you with a code example for the operation of a standard servo motor, and the code is applicable for both the MG90 and the larger MG996. This example code, provided, can form the basis of the assessed exercise for the servo integrated onto the robot chassis.</p> <p>During this exercise, we will use the circuit shown in Fig. 1, where:</p> <ul> <li>The red wire of the servo is the positive supply, and is connected to the 5V if the Arduino</li> <li>The brown wire is the negative supply and should be connected to the ground line.</li> <li>The orange wire is the control line and should be connected to a PWM enabled I/O pin on the Arduino board, in this example, pin 9.</li> </ul> Circuit diagram for this Exercise. <p>Info</p> <p>Connecting the wires directly into the servo connector will result in a weak mechanical connection. This connection should be sufficient for this exercise, but if you wish for a more robust connection, you can push the male header pins into the breadboard and use this as intermediate connection.</p> <p>Procedure:</p> <ol> <li>Connect the circuit shown in Fig. 1.</li> <li>Download the Standard_Servo_Example.ino code from the Blackboard folder for this practical. Also included below:</li> </ol> <p>Arduino code for the Standard_Servo_Example.ino Example <pre><code>// This Example code is for use with the Controlling a Standard Servomotor exercise\n//\n\n// Include the servo library to allow for connection and control of servo motors\n#include &lt;Servo.h&gt;\n\n// define the macro pinServo1 as 9, to use for connecting the servo to pin 9\n#define pinServo1 9\n\n// Declare a servo motor class variable servo 1\nServo servo1;\n\n// -------------------------------------\n// Setup function\nvoid setup()\n{\n  // \"attach\"  servo 1 to the defined pin\n  servo1.attach(pinServo1);\n\n  // set the neutral, centre, position for the servo\n  servo1.write(90);\n\n  // Alternte command for setting the neutral position\n  //servo1.writeMicroseconds(1500);\n\n  // wait until the servo has moved into position, (1000ms is more time than needed)\n  delay(1000);\n}\n\n// -------------------------------------\n// Loop Function\nvoid loop()\n{\n  // start from the nuetral position, (90 degrees from the fully clockwise position)\n  servo1.write(90);\n  //servo1.writeMicroseconds(1500);  // Alternate Command\n\n  // wait until the servo has moved into position\n  delay(1000);\n\n  // move to  0 degrees, (fully clockwise)\n  servo1.write(0);\n  //servo1.writeMicroseconds(500);  // Alternate Command\n\n  // wait until the servo has moved into position\n  delay(1000);\n\n  // move to 180 degrees, (fully anti cloclwise position)\n  servo1.write(180);\n  //servo1.writeMicroseconds(2500);  // Alternate Command\n\n  // wait until the servo has moved into position\n  delay(1000);\n}\n</code></pre></p> <p>Looking at the code, above, you will see that the servo library had been included in the sketch. This external is library containing several functions that allow the Arduino to control a variety of servo motors. The Arduino reference library webpage for the servo library is located here:</p> <p>https://www.arduino.cc/reference/en/libraries/servo/</p> <p>Before you can use the servo control commands in your code, you must first perform the following operations in your code, (look at the code to see how this has been done):</p> <ul> <li>In the global namespace area:<ul> <li>Include the servo library <code>Servo servo1;</code></li> <li>Declare a servomotor class variable. This is used by the Arduino IDE to direct your commands to the correct servo motor.</li> </ul> </li> <li>In the <code>setup()</code> function:<ul> <li>The servo motor class needs to be linked to an output pin. This is achieved using the <code>attach()</code> function. </li> </ul> </li> </ul> <p>In Standard_Servo_Example.ino we have declared a servo class variable as <code>servo1</code>, we have defined I/O pin 9 as the servo control pin, and we attached the <code>servo1</code> class to pin 9, using the following command: <code>servo1.attach(pinServo1);</code></p> <p>The servomotor is controlled using an encoded PWM signal. The on time of the PWM signal should be bounded between 1000\u03bcs and 2000\u03bcs, with a pulse repetition rate between 40 and 200Hz, i.e. a period between 5ms and 25ms.</p> <p>The servo centre position, or \u2018neutral\u2019 position, of the servo is commanded using a 1500\u03bcs pulse width. Typically, the 90\u00b0 clockwise position is commanded with a pulse width of approximately 500\u03bcs, and the 90\u00b0 anticlockwise position is commanded with a pulse width of approximately 2500\u03bcs. These 90\u00b0 position pulse widths are often slightly different for each servo model, so you may need to refine these timings for servos you have been provided.</p> <p>The servo library has two functions for controlling the position of the servo:</p> <ul> <li><code>write()</code>, which directly commands the servo angle.</li> <li><code>writeMicroseconds()</code>, which commands a specifically timed pulse width for the servo output.</li> </ul> <p>The <code>write()</code> function may not be accurate for the servomotors you have been provided, and may vary between different models. You should investigate the accuracy of these commands when using the <code>write()</code> and <code>writeMicroseconds()</code> for applications which require accurate output angles.</p> <ol> <li>Look at the Standard_Servo_Example.ino code, and see how the servo library has been used, how a servo is declared and attached to the system.</li> <li>Run the sketch and observe its operation</li> </ol>"},{"location":"BasicExercises/Ex4DriveServoMotor/#controlling-a-standard-servo-with-an-external-power-supply","title":"Controlling a Standard Servo with an External Power Supply","text":"<p>The previous exercise demonstrates how to connect and power a small servo directly from the pins of the Arduino device. When operating with several small servos, or one or more larger servos, the power supply from the Arduino will not be capable of providing the power supply requirements for this load. This may result in the servos not working at all, or unpredicted system behaviour, due to Brownout reset.</p> <p>This section will show how to power the servos from an external power supply, while controlling them from the Arduino.</p> <p>The SG90 is a very low power servo motor and can be driven directly from the Arduino board power supply, as shown in Fig. 1.</p> <p>If we wish to connect a larger servo to the system, then we must use an external power supply to power the servo, as illustrated in Fig. 2. In Fig. 2, we can see that the red, +5V line is supplied from the external power supply, and the GND line of all the elements, Arduino, power entry socket, and servo are linked. This is to ensure that all the circuit elements are referenced to the same voltage.</p> Wiring diagram for the servo powered from an external power supply. <p>The pin connections for the external power supply connector, (provided in the mechatronics kit box), are shown in Fig. 3.</p> Annotated picture of the external power supply connector pins. <p></p>"},{"location":"BasicExercises/Ex4DriveServoMotor/#assessed-exercise-driving-the-mg996-servo-on-the-front-of-the-robot-chassis","title":"Assessed Exercise: Driving the MG996 Servo on the front of the Robot Chassis","text":"<p>Before Starting This Exercise</p> <p>Ensure that you have the servo and the external power supply connected, as described in the Electrical Connections section of the Building the Robot Document</p> <p>The aim of this exercise is to demonstrate that you can operate a standard servo powered from an external supply. , and reset the servo to the null position. </p> <p>Procedure:</p> <ul> <li>Before starting this exercise, you will need to remove the lolly stick assembly from the MG996 servo on the robot chassis</li> <li>Write a program to reset the servo to the null position, using the command: <code>servo1.write(90);</code></li> <li>While the servo is in the null position, reattach the lolly stick assembly, with the arm as close to horizontal as the servo shaft will allow.</li> <li>Write a program to perform the following:<ul> <li>When the Arduino is reset, or initially programmed, the servo arm (lolly stick assembly) should be set to a horizontal position.<ul> <li>You will need to adjust the initial angle of the servo in code to achieve this.</li> </ul> </li> <li>The three LEDs should flash three times, (on for 500ms and off for 500ms).</li> <li>The servo arm should then raise to the vertical position and maintain this position for 2 seconds.</li> <li>Repeat the above procedure once and then finally hold the servo arm in the vertical position.</li> </ul> </li> </ul> <p>The power supply of your servo MUST be supplied from the external power supply and not the Arduino +5V. The GND of the Arduino, external supply and servo must be connected to the same node.</p> <p>Danger: You can destroy your Laptop motherboard if you get this wrong</p> <p>If you connect the +5V supply of the Arduino and the external power supply together you risk destroying the motherboard of your laptop by sending a voltage spike up the USB lead when the servo operates.</p> <p>Read the Disclaimer document before proceeding.</p> <p>The University or MEE take no responsibility for damaged laptops due to this issue. We recommend using the University IT equipment to mitigate damaging your equipment.</p> <p>When completed, your code should function as follows:</p> <p>Your Servo must be powered from the external power supply during this exercise.</p> <ul> <li>When the Arduino is reset, or initially programmed, the servo arm (lolly stick assembly) should be set to a horizontal position.<ul> <li>You will need to adjust the initial angle of the servo in code to achieve this.</li> </ul> </li> <li>The three LEDs should flash three times, (on for 500ms and off for 500ms).</li> <li>The servo arm should then raise to the vertical position and maintain this position for 2 seconds.</li> <li>Repeat the above procedure once and then finally hold the servo arm in the vertical position.</li> </ul> <p>Now Get Your Work Marked by a GTA</p> <p>Once you have completed your code and are satisfied with its operation, you should show your work to a GTA for marking.</p>"},{"location":"BasicExercises/Ex5DcMotor/","title":"DC Motor","text":"<p>GTA Marking</p> <p>This is an assessed Exercise. When you have completed the Assessed Exercise, you should show your work to a GTA to get marked.</p> <p>Note</p> <p>Before starting these exercises, you should ensure that you have completed the circuit on the robot chassis, as suggested on Building the Robot: Fig. 13. Furthermore, you should ensure that all the connections described in the Building the Robot: Circuit Layout for the DC Motor Exercise are correct.</p> <p>The following video is a quick demonstration of the final outcome from this exercise:</p> Video demonstrating the expected outcome from this exercise"},{"location":"BasicExercises/Ex5DcMotor/#introduction","title":"Introduction","text":"<p>The aim of this exercise is to control a DC motor from an Arduino, using a DC motor driver interface. You will be using a PWM signal to drive the motor.</p>"},{"location":"BasicExercises/Ex5DcMotor/#pwm-control-for-the-dc-motor","title":"PWM Control for the DC Motor","text":"<p>PWM is a way of encoding information into a rectangular pulse train. Generally, the period, (and hence the frequency), of the pulse train is maintained constant, and the width of the rectangular pulses are varied \u2013 we will assume this definition for the remainder of these laboratory sessions.  Fig 1 illustrated the time domain waveform of the PWM signal, where the digital waveform has a rising edge at t=t<sub>0</sub>, and a falling edge at t=t<sub>2</sub>. The on-state of the PWM signal is defined as t<sub>on</sub>, the off-state of the signal is defined as t<sub>off</sub>, and the PWM period is defined as T<sub>s</sub>.</p> Pulse Width Modulation, (left) time domain waveforms, (rich) average voltage of PWM signal. <p>PWM can be used in a number of different ways; the most common being to \u2018chop\u2019 a DC voltage to reduce its average value, as illustrated graphically in Figure 13. The input voltage, V<sub>in</sub> is \u2018chopped\u2019, using a converter circuit, into pulses, as shown in Figure 13 (left), where the time integral of the on-state of the waveform is t<sub>on</sub> x V<sub>in</sub>, and has a graphical area of A. The filtering effect of the system we are driving will effectively spread the area under the pulse across in, Fig 1 (left) , across the switching period, Ts, as illustrated in Fig 1 (right). </p> <p>This can be expressed as an integral equation:</p> <p> $$ V_{ave} = \\frac{1}{T} \\int_{t_0}^{t_2} V_{in} dt = \\frac{t_{on}} {T_{s}}V_{in} $$</p> <p>Where: V<sub>in</sub> is the supply voltage, and V<sub>ave</sub> is the average value of the waveform.</p> <p>This method of operation is used in most electrical power converters to control the power supply to downstream system, such as a motor. Another way in which PWM can be used, is to encode some information as a function of the on-state time, t<sub>on</sub>, whilst maintaining a constant switching period, T<sub>s</sub>. The PWM signal is then decoded by the downstream system and a decision is made on its value.</p> <p>During the laboratory exercises, you will be driving two different types of actuators:</p> <ol> <li>A DC motor - to control the speed of rotation, you will need to control the PWM to regulator the average voltage being fed to the DC motor. To interface the motor to the Arduino, you will need to use a motor drive circuit, to supply the current requirements of the motor.</li> <li>A standard servomotor - this servomotor will move between 0 and 180 degrees and the angle can be controlled through a 5V pulse signal between 1-2ms and an embedded potentiometer</li> </ol> <p>The DC motor is different from the standard servomotor, in terms of the type of control. For servomotors, the average value of the PWM signal is not being used to regulate the average supply voltage to the device, like it is for DC motors, but instead, the PWM on-time is bounded between 2 values, (1ms and 2ms in this case), and is an encoded signal relating to a rotational position demand parameter for the servomotor, closed loop, controller.</p>"},{"location":"BasicExercises/Ex5DcMotor/#code-example-control-led-intensity-example","title":"Code Example: Control LED Intensity Example","text":"<p>In this example, we will use the <code>analogWrite()</code> function to generate a PWM signal, which we will use to vary the voltage supplied to an LED, and hence the LED intensity.</p> <p>A PWM signal can be generated by the <code>analogWrite()</code> function. The value passed to the <code>analogWrite()</code> function can be between 0 and 255, which results in a PWM output between 0% and 100% duty cycle, as illustrated in Fig 2. </p> . Illustration of the use of analogWrite() function, and the resulting PWM output. <p>(Fig 2 is taken from: https://commonpwmAverages.wikimedia.org/wiki/File:Pwm_5steps.gif)</p> <p>The Arduino language reference page for the analogWrite command can be found at: https://www.arduino.cc/reference/en/language/functions/analog-io/analogwrite/.</p> <p>Procedure:</p> <ol> <li> <p>The circuit requirement for this exercise is the LED Pattern circuit, so you should have already built thin onto the robot chassis.</p> </li> <li> <p>Use the following example code to run this exercise:</p> </li> </ol> <p>LED Fade.ino Example<pre><code>//This sketch is the Control LED Intensity Example from the Introduction to\n// Arduino \u2013 PWM control of Actuators laboratory worksheet\n\n// define a macro for the LED pin number \n#define LEDpin 11\n\n// -------------------------------------\n// Setup function\nvoid setup() {\n  // define the pin mode for the LED pin\n  pinMode(LEDpin, OUTPUT);\n\n}\n// -------------------------------------\n// Lop Function\nvoid loop() {\n\n  // Increment a variable, i, from 0 and 255\n  for (int i = 0; i &lt; 256; i++)\n  {\n    // modify the PWM signal, by passing the variable, i, to the \n    //analogWrite function\n    analogWrite(LEDpin, i);\n    //delay the program by 10ms\n    delay(10);\n  }\n  // Decrement a variable, i, from 255 to 0\n  for (int i = 255; i &gt;= 0; i--)\n  {\n    // modify the PWM signal, by passing the variable, i, to the \n    //analogWrite function\n    analogWrite(LEDpin, i);\n    //delay the program by 10ms\n    delay(10);\n  }\n}\n</code></pre> 3. Run the program and observe the effects on the LED of the different values being passed to the <code>analogWrite()</code> function.</p>"},{"location":"BasicExercises/Ex5DcMotor/#using-the-tb6612fng-breakout-board","title":"Using the TB6612FNG breakout board","text":"<p>A DC motor cannot be powered directly from the pins of the Arduino board, because the current drawn by the DC motor is too large and could damage the Arduino by overloading the output pins. To overcome this problem, a power electronic driver circuit is required to interface the motor to the Arduino microcontroller board. During this exercise, you will be using a TB6612FNG motor driver breakout board, as shown in Fig 3, and an external power supply, to drive motor from control signals generated in the Arduino.</p> Picture of the TB6612FG motor driver board, with pins labelled. <p>This section is aimed at providing you with some useful information, to help you get started with using the TB6612FNG breakout board. This section will not provide you with all the information you may need, so it will be up to you to research other sources of information to help. There are numerous online guides detailing the interfacing of this breakout board with an Arduino controller.</p> <p>The TB6612FNG, from TOSHIBA, is a monolithic bridge driver IC, in other words, it is a single integrated circuit containing the power electronic switching and control interface circuitry required for implementing a bridge motor driver circuit. The TB6612FNG contains two independently controlled H-bridge drive circuits. See the data sheet, linked in the following section for more details.</p> <p>In isolation, an integrated circuit can be difficult to interface with a control system, without a custom PCB design. The use of breakout board circuits provides a convenient way of connecting surface mount chips to breadboard prototyping circuit, and interfacing then with control processors, such as the Arduino devices we will be using.  The TB6612FNG board, shown in Fig 3, is a breakout board for the TB6612FNG IC, and is packaged with the required capacitors to correctly operate the device. The pin descriptions for each pins on the TB6612FNG breakout board are described in Table 1:</p> Pin label: Description: VmMotor power circuit supply (2.5V to 13.5V) VccLogic circuit supply (2.7V to 5.5V) GNDGround StandbyStandby input (200k\u03a9 pull-down internally) Low = Standby, High = Active AI1Channel A input 1 (200k\u03a9 pull-down internally) AI2Channel A input 2 (200k\u03a9 pull-down internally) PWMAChannel A PWM input  (200k\u03a9 pull-down at internal) AO1Channel A Output 1 AO2Channel A Output 2 BI1Channel B input 1 (200k\u03a9 pull-down internally) BI2Channel B input 2 (200k\u03a9 pull-down internally) PWMBChannel B PWM input  (200k\u03a9 pull-down at internal) BO1Channel B Output 1 BO2Channel B Output 2 Pin descriptions for the TB6612FNG breakout board."},{"location":"BasicExercises/Ex5DcMotor/#online-documentation-from-the-manufacturer-and-other-sites","title":"Online Documentation from the manufacturer and other sites","text":"<p>Semiconductor manufacturers often provide information for the use of their manufactured devices in the form of a data sheet, and often provide application notes and other material for more complicated classes of device. Links to some relevant manufacturer\u2019s documentation and some other relevant application documents are provided:</p> <ul> <li>TB6612FNG Data sheet (TOSHIBA): TB6612FNG Data sheet.</li> <li>Data Sheet for the breakout board (Sparkfun): SparkFun Motor Driver - Dual.</li> <li>Application note (ST Microelectronics): Applications of Monolithic Bridge Driver.</li> <li>Presentation/Training Material (ST Microelectronics): An Introduction to Electric Motors.</li> </ul>"},{"location":"BasicExercises/Ex5DcMotor/#h-bridge-circuit-and-example-code","title":"H-Bridge Circuit and Example Code","text":"<p>The TB6612FNG IC is configured to operate as two independent H-bridge circuits, we will only discuss the operation of a single H-bright Circuit, using channel B. The outputs for channel B are BO1 and BO2, and this is controlled using the PWMB signal. The direction of rotation can be configured using the BI1 and BI2 inputs. The operation of an H-bridge circuit is covered in the lecture material for this course, so will not be discussed in detail in this document.</p> <p>Before proceeding, ensure that you have constructed the H-bridge circuit in Circuit Layout for the DC Motor Exercise.</p>"},{"location":"BasicExercises/Ex5DcMotor/#operation-of-the-tb6612fng-driver-board-circuit","title":"Operation of the TB6612FNG Driver Board Circuit","text":"<p>Each H-bridge circuit is configured using two control inputs, In1 and In2, with a separate PWM input for each bridge. The control operation of the H-bridge is described in Table 2.</p> Input: Output: In1In 2PWMSTBYOut1Out2Mode HighHighHigh/LowHighLowLowBrake LowHighHighHighLowHighForward (Drive) LowHighLowLowForward (Freewheel) HighLowHighHighHighLowBackward(Drive) LowHighLowLowBackward(Freewheel) LowLowHighHighOFF (High Impedance)Stop (Coast) High/LowHigh/LowHigh/LowLowOFF (High Impedance)Standby Control operation of the H-bridge. <p>In essence, Table 2 indicates that the direction of the motor is configured using the In1 and In2 inputs, (BI1 and BI2, respectively for channel B), and the speed of the motor is controlled with the PWM input, (PWMB for channel B). The standby input is provided to set the driver board into a power sleep state.</p> <p>Note</p> <p>The wiring polarity of the motor power, will define if forward is clockwise or anticlockwise rotation. If the connection of the motor is reversed on Out1 and Out2, then the motor will spin in the opposite direction.</p> <p>Example code is provided, below, to demonstrate simple operation of this motor. The <code>analogWrite()</code> function is used to generate the PWM value for the PWM output, in the following manner:</p> <ul> <li>0% duty cycle, (always Low): <code>analogWrite([PWM pin number], 0)</code></li> <li>100% duty cycle, (always High): <code>analogWrite([PWM pin number], 255)</code></li> <li>Duty cycle between 0% and 100% be generated by writing values of between 1 and 254 to the <code>analogWrite()</code> function.</li> </ul> <p>The Arduino language reference page for the <code>analogWrite()</code> function can be found at: https://www.arduino.cc/reference/tr/language/functions/analog-io/analogwrite/</p>"},{"location":"BasicExercises/Ex5DcMotor/#sample-code-for-the-tb6612fng-driver-board","title":"Sample Code for the TB6612FNG Driver Board","text":"Sample Code for the TB6612FNG Driver Board<pre><code>// TB6612FNG Driver Board Sample board\n//\n// Author: Ben Taylor\n// University of Sheffield\n// Date: September 2024\n\n//\nconst int pinBI1 = 7;       // Pin allocation for BI1\nconst int pinBI2 = 8;       // Pin allocation for BI2\nconst int pinPWM = 5;       // Pin allocation for the PWMB pin\n\nboolean BI1 = 0;            // BI1 pin value\nboolean BI2 = 0;            // BI2 pin value\nboolean standBy = 0;        // standBy pin Value\n\nboolean rotDirect = 0;      // Rotation direction variable\nunsigned char pwmValue = 0; // PWM value to be written to the output\n\nvoid setup()\n{\n  // Assign the digital I/O pin directions\n  pinMode(pinBI1, OUTPUT);\n  pinMode(pinBI2, OUTPUT);\n  pinMode(pinPWM, OUTPUT);\n\n\n  //Initialize the serial port\n  Serial.begin(9600);\n\n  // Set Initial values for BI1 and BI2 control function pins\n  BI1 = 1;\n  BI2 = 0;\n\n  // set an initial value for the PWM value\n  pwmValue = 200;\n}\n\nvoid loop()\n{\n  // Write the BI1 and BI2 values to the configuration pins\n  digitalWrite(pinBI1, BI1);\n  digitalWrite(pinBI2, BI2);\n\n  // Write the pwnValue to the PWM pin\n  analogWrite(pinPWM, pwmValue);\n\n  // Display the board variable status to the Serial Monitor\n  Serial.print(\"PWM output value = \");\n  Serial.print(pwmValue);\n  Serial.print(\", Standby = \");\n  Serial.print(standBy);\n  Serial.print(\", BI1 = \");\n  Serial.print(BI1);\n  Serial.print(\", BI2 = \");\n  Serial.println(BI2);\n\n  // wait 250ms\n  delay(250);\n}\n</code></pre>"},{"location":"BasicExercises/Ex5DcMotor/#assessed-exercise","title":"Assessed Exercise","text":"<p>During this exercise, you will modify the example code </p> <p>Procedure:</p> <ul> <li>Copy and Paste the Sample Code for the TB6612FNG Driver Board into a new Arduino sketch.</li> <li> <p>Read the code, and inline comments. Run the code, and observe its operation.</p> </li> <li> <p>Write a program that can control the speed of the DC motor using a potentiometer input. </p> <ul> <li>The motor should rotate at maximum speed in a clockwise direction, when viewed from the shaft end, when the potentiometer is rotated to the extreme clockwise position.</li> <li>The motor should rotate at maximum speed in an anticlockwise direction, when viewed from the shaft end, when the potentiometer is rotated to the extreme anticlockwise position.</li> <li>When the potentiometer is in the centre position the motor shaft should be at zero speed, (stopped)</li> <li>The speed of the motor should vary in a linear fashion between maximum speed, when the potentiometer is at its extreme rotation, and zero speed when the potentiometer is in the centre position.</li> <li>You should display the following values on the serial monitor terminal, (with a similar text description to the sample code, above):<ol> <li>ADC measurement value for the Potentiometer input</li> <li>PWM value, written to the analogWrite command</li> <li>Boolean values for AI1, AI2 and Standby</li> </ol> </li> </ul> </li> </ul> <p>What do we expect to see in the demonstration?</p> <ul> <li>Demonstrate that you have fulfilled the requirements of the exercise with your working system.</li> <li>The mapping of the potentiometer to shaft speed is consistent with the description above.</li> <li>An external power supply is used to power the motor circuit, (Vm on the driver board).</li> <li>ADC measurement from the potentiometer, PWM value and control logic Boolean values are clearly labelled and displayed on the serial monitor.</li> <li>The serial monitor should update at a reasonable rate \u2013 2 to 4 times a second.</li> </ul> <p>Now Get Your Work Marked by a GTA</p> <p>Once you have completed your code and are satisfied with its operation, you should show your work to a GTA for marking.</p>"},{"location":"BasicExercises/Ex6EncodeMotor/","title":"Interfacing the Incremental Encoder from the Gear Motor","text":"<p>GTA Marking</p> <p>This is an assessed Exercise. When you have completed the Assessed Exercise, you should show your work to a GTA to get marked.</p> <p>Note</p> <p>Before starting these exercises, you should ensure that you have completed the circuit on the robot chassis, as suggested on Building the Robot: Fig. 15. Furthermore, you should ensure that all the connections described in the Building the Robot: Circuit Layout for the Encoders and Motor Exercise are correct.</p> <p>The following video is a quick demonstration of the final outcome from this exercise:</p> Video demonstrating the expected outcome from this exercise"},{"location":"BasicExercises/Ex6EncodeMotor/#introduction-and-background","title":"Introduction and Background","text":"<p>Rotary sensors are used to measure the position and/or speed of a rotating body, (generally a shaft), and can either have an analogue or digital output. The term rotary encoder generally described a digital rotational position sensor. </p> <p>Rotary position encoders come in two different types:</p> <ol> <li>Absolute position encoder: This class of devices will indicate the absolute position of a rotating body. This measurement does not require an initial position reference. </li> <li>Incremental position encoder: This class of device will indicate the position of the rotating shaft, relative to an initial position or index point. Absolute position can be obtained by knowing the exact initial position, at start-up, or index point, (if the device has an index pulse).</li> </ol> <p>The following link will provide you with some further insight into rotary position encoders:</p> <p>https://en.wikipedia.org/wiki/Rotary_encoder</p> <p>Rotary speed can be measured by a rotary shaft encoder, often called a tachometer \u2013 we will not further discuss these devices in this document. Shaft speed can be calculated from the position encoder, by measuring the displacement of a rotary shaft and dividing this by the time interval between measurements.</p> <p>The sensing technologies for position encoders varies between devices, but the two most common are optical and magnetic. The incremental encoder used on the FIT0450 gear motor, (contained within the Mechatronics kit), is a magnetic quadrature encoder. This is a specific type of incremental encoder called a quadrature encoder and has two square wave outputs, A and B, both offset by 90\u00b0, as illustrated in Fig 1.</p> Example of the quadrature encoder output. <p>Figure 20 shows the quadrature encoder attached to the FIT0450 gear. This device has a 120:1 gear box attached between the motor and the output shaft. There is a quadrature encoder, comprising of an 8 pole-pair magnetic disc, attached to the back of the motor shaft, and 2 offset Hall effect switch sensors, mounted to the motor body.</p> <p>What is the difference between a sensor and a switch sensor?</p> <p>With an analogue sensor device, the output of the device is a continuous variable quantity and may require signal conditioning before the output can be read by a microcontroller. In the case of a switch sensor, the output is either a LOW or HIGH digital level, and the switch sensor contains all or most of the signal conditioning required to interface with a microcontroller.</p> Connections between the encoder and the Arduino and components of the encoder. <p>As the disk rotates, each time a north pole of the magnet passes a Hall effect switch, the output changes from 0 to 1 and back to 0 when the south pole passes. This results in a square wave output from the Hall effect switch as the shaft rotates. The encoder has two Hall outputs, A and B, one for each Hall effect switch sensor. The sensors are offset 90\u00b0, (electrically), around the circumference of the disk, consequently, outputs A and B are 90\u00b0 out of phase with respect to each other, as shown in Fig 1. This difference in phase is crucial in determining the direction of rotation of the disc, such that, output A will lead B in one direction and output B will lead A in the other.</p> <p>The number of magnetic sections of the disc determines the number of \u201cpulses per revolution\u201d, which is a characteristic of each encoder. This is important in determining the minimum detectable angle of rotation and, therefore, the accuracy of the system overall. </p> <p>As mentioned above, there are 8 magnetic pole pairs on the disk, consequently, there are 8 pulses on the output of each sensor for one revolution of the magnetic disk. The motor has a 120:1 gear box, therefore, for one rotation of the output shaft there will be \\(8\\times120=960\\) pulses on the output of each sensor (or \\(960\\times4\\) digital edges). The positional accuracy of the encoder is, therefore, 960 pulses per revolution, or:</p> \\[  \\frac{360\u00b0}{960 \\space pulses \\space per \\space revolution} = 0.375\u00b0 \\space per \\space pulse. \\] <p>When using a quadrature encoder with a microcontroller, the rotation of the encoder can be fast, leading to high frequency pulses. As a result, trying to read the states of the encoder outputs in the Arduino loop function is not a reliable method for reading the quadrature encoder. If the microcontroller is busy executing other instructions when the pin\u2019s state changes, then the pulse is not counted, resulting in a mismatch between the real angle and the software measurement. A much more reliable way of acquiring the outputs A and B is through a special feature of the microcontroller called an interrupt. The interrupt module can be used to sense an event on a digital input, (in this case the encoder output), and run a special piece of code, to \u201cservice\u201d the interrupt. This special piece of code is called an interrupt service routine, or ISR.</p> <p>In the case of reading the quadrature encoder, we use a level change interrupt on the pins of the microcontroller, attached to the quadrature encoder. Each time there is a level transition in either output A or B, the main code is interrupted and the ISR is run by the microcontroller. This means that whatever the microcontroller is busy doing, the execution is stopped to process the interrupt, and no pulses are lost.</p> <p>There several ways of using the interrupts to measure the encoder outputs. For maximum resolution, two interrupts are required, but a single interrupt can be used to produce a position resolution of half this resolution. </p> <p>The method, illustrated in Table 1, uses a counter to track the \u201cpulse\u201d position of the encoder, and two interrupts for the two inputs, A and B. One ISR is attached to the A pin interrupt and processes the event associated with a change in the A input value, and similarly, there is an ISR for input pin B. Table 3 illustrates the operation of the two ISR servicing the A and B pin interrupts. When an encoder interrupt occurs on either pin A or B, the pin values are compares and the counter value is either incremented or decremented, depending on the A and B pin values and the logical function described in Table 1. Table 1 also shown which ISR each line of the table is processed.</p> <p></p> ROTATION:OUTPUT A:OUTPUT B:Which ISR?COUNT: CW0\u219210A+1 10\u21921B+1 1\u219201A+1 01\u21920B+1 CCW0\u219211A-1 11\u21920B-1 1\u219200A-1 00\u21921B-1 Control operation of the H-bridge. <p>The following code snippet is a framework to setup pins D2 and D3 as digital inputs and assign each one an interrupt service routine, <code>ChannelA()</code> and <code>ChannelB()</code>, respectively.</p> <p>The code provided, below, is a framework to set up the interrupt capable, digital input pins for the Arduino Uno, D2 and D3. The functions <code>ChannelA()</code> and <code>ChannelB()</code> are declared as ISRs using the <code>attachInterrupt()</code> function.</p> <p>How to setup The D2 and D3 pins as interrupt capable<pre><code>#define PINA 2 // A output of the  encoder attached to PIN 2 of the Arduino\n#define PINB 3 // B output of the  encoder attached to PIN 3 of the Arduino\n\nvolatile long enc_count = 0; // Pulse count from the quadrature encoder\n\nvoid setup(){\n  // Initialize the A and B input pins\n  pinMode(PINA, INPUT);\n  pinMode(PINB, INPUT);\n\n  // Attach interrupt to PINA. When the pin changes state, the function \n  // channelA() is called.\n  attachInterrupt(digitalPinToInterrupt(PINA),channelA, CHANGE);\n  // Attach interrupt to PINB. When the pin changes state, the function \n  // channelB() is called.\n  attachInterrupt(digitalPinToInterrupt(PINB),channelB, CHANGE);\n\n}\n\nvoid loop() {\n...\n}\n\nvoid ChannelA(){\n...\n}\n\nvoid ChannelB(){\n...\n}\n</code></pre> See the following link for a fuller description of the attachInterrupt() function:</p> <p>https://www.arduino.cc/reference/tr/language/functions/external-interrupts/attachinterrupt/</p> <p>We use the CHANGE option with the attachInterrupt() function to ensure that the interrupt is generated for both rising and falling transitions of the interrupt pins, A and B.</p> <p>Note: the enc_count variable has been declared as \u201cvolatile\u201d. This is required for variables that will be changed in an ISR, because the memory storage needs to be handled slightly differently for that usage of variables. See the following link for more details:</p> <p>https://www.arduino.cc/reference/en/language/variables/variable-scope-qualifiers/volatile/</p> <p>Note Regarding Interrupt Pins on the Arduino</p> <p>On the Arduino UNO, only pins D2 and D3 can be used with the attachInterrupt() function. On an Arduino Mega, pins D2, D3, D18, D19, D20, D21 are available (D20 and D21 cannot be used if I2C is used used (I2C is a communication protocol for some specific sensors; not among those in the Mechatronics kit)). </p> <p>Before attempting to control the rotation of the shaft of a DC motor, you should convert the encoder output into a useful value, suggestions are output shaft revolutions or wheel angle. The following equations can be used to calculate these values:</p> \\[ shaft \\space revolutions=\\frac{pulse \\space count}{pulses \\space per \\space revolution} \\] <p>If the angle is required instead:</p> \\[ shaft \\space revolutions=360\u00b0\\times\\frac{pulse \\space count}{pulses \\space per \\space revolution} \\] <p>Remember</p> <p>The above Equations relate to complete pulses on each data line. The presented code will increment a counter for each digital edge on both A and B data lines, therefore, the shaft ravolutions and the shaft angle will be quarter of the calculated value, using the code templates provided.</p>"},{"location":"BasicExercises/Ex6EncodeMotor/#reading-the-output-of-the-incremental-encoder","title":"Reading the Output of the Incremental Encoder","text":"<p>The aim of this exercise is to read the encoder position and display this on the serial monitor.</p> <p>Before starting, you should ensure that all the connections described in the Building the Robot: Circuit Layout for the Encoders and Motor Exercise are correct.</p> TwoInterruptEncoder.ino Example Code Template<pre><code>#define ENC_K [Insert the value for the FIT0450 Gearmotor] //Number of edges\n//  per revolution of the output shaft\n#define PINA 2 // A output of the quadrature encoder attached to PIN 2\n#define PINB 3 // A output of the quadrature encoder attached to PIN 3\n\n//These two variables are declared as volatile because they are updated\n// within an ISR\nvolatile long encCount; // Pulse count from the quadrature encoder\nvolatile float wheelAngle; // Angle of the output shaft of the gear motor,\n// attached to the wheel\n\n// initialise the lastDisplay variable\nlong lastDisplay = 0;\n#define delayDisplay 250\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(PINA, INPUT);\n\n  // Attach interrupt to PINA. When the pin changes state, the function channelA()\n  // function is called.\n  attachInterrupt(digitalPinToInterrupt(PINA),channelA, CHANGE);\n\n  // Attach interrupt to PINB. When the pin changes state, the function channelB()\n  // function is called.\n  attachInterrupt(digitalPinToInterrupt(PINB),channelB, CHANGE);\n\n  encCount = 0;\n  wheelAngle = 0;\n}\n\nvoid loop() {\n\n  // Update the Serial Monitor every 250ms\n  if (millis() &gt;= lastDisplay + delayDisplay) {\n\n    // update lastDisplay to the current millis() time\n    lastDisplay = millis();\n\n    // construct the serial monitor messages\n    Serial.print(\"Encoder Pulse Count = \");\n    Serial.print(encCount);\n    Serial.print(\"Wheel angle = \");  \n    Serial.print(wheelAngle);\n    Serial.println(\"\u00b0\");\n  }\n}\n\nvoid channelA() {\n// Use if else statements to increment or decrement the encCount variable\n// Use information in the table in the Encoder section of the The Rotary \n// Position Encoder section of the laboratory Documentation.\n// Focus on the table rows where Output A is changing\n// Use digitalread() to acquire the states of PINA and PINB\n\n  if([insert a logic statement here]) {\n    if([insert a logic statement here]){\n      encCount++; // Encoder rotating in one direction, e.g. clockwise\n    }\n    else {\n    // Encoder rotating in the opposite direction, e.g. counter clockwise\n    encCount--; \n    }\n  }\n  else{\n    if([insert a logic statement here]){\n      encCount++; // Encoder rotating in one direction, e.g. clockwise\n    }\n    else {\n    // Encoder rotating in the opposite direction, e.g. counter clockwise\n    encCount--; \n    }\n  }  \n\n  //compute the angle of rotation of the wheel using the pulse count, encCount\n  wheelAngle = ; \n\n}\nvoid channelB() {\n  // Use function channelA() as a template\n  // This time focus on the rows of the table where Output B is changing\n}\n</code></pre> <p>Remember</p> <p>This Interrupt Method counts the digital edges of the A and B signals, not the number of pulses. As a result, there are \\(4\\times\\) the number of edges to pulses, therefore, the output count will be \\(4\\times\\) greater than the number of pulses.</p> <p></p>"},{"location":"BasicExercises/Ex6EncodeMotor/#reading-the-rotary-encoder-exercise","title":"Reading the Rotary Encoder Exercise","text":"<p>The aim of this exercise is for you to develop the Encoder Read functionality before you attempt to use the encoders in conjunction with actuating the motor.</p> <p>This is a non-assessed exercise, but it is strongly recommended that you complete this exercise before proceeding, because it provides you with the first half of the requirements for the Assessed Exercise. <p>Procedure:</p> <ol> <li>Copy and paste the code provided, above, into a new Arduino sketch.</li> <li>The code for the pin A ISR, channelA(), is partially completed. You should implement the logic function for the A interrupt illustrated in Table 1.</li> <li>Use your working for the <code>ChannelA()</code> code to write the code for the <code>ChannelB()</code> function.</li> <li>Modify the code to update the serial monitor display every 250ms.</li> <li>Ensure that you have set the <code>ENC_K</code> value to the number of digital edges per revolution, not number of pulses</li> <li>Run your code and rotate the motor wheel. The Serial Monitor should display the correct values.</li> </ol> <p>Stop Using the <code>Delay()</code> Function</p> <p>For the timing of the serial monitor, you should use the millis() method in the TwoInterruptEncoder.ino template file, and not use the delay() method. Inserting delay functions into your code is bad practice and can cause problems during future development.</p> <p></p>"},{"location":"BasicExercises/Ex6EncodeMotor/#assessed-exercise","title":"Assessed Exercise","text":"<p>The aim of this exercise is to measure the wheel angle of the gear motor, using the quadrature encoder, and move the wheel angle to a series of desired locations. During this exercise you will be required to integrate the code form:</p> <ul> <li>The Reading the Rotary Encoder Exercise, above</li> <li>The DC Motor: Assessed Exercise</li> </ul> <p>Procedure:</p> <p>Write a program that can rotate the wheel connected to the DC motor according to the following cycle:</p> <ol> <li>From an initial starting point, rotate the wheel 45\u00b0 clockwise</li> <li>Wait for 1 second</li> <li>Rotate the wheel 45\u00b0 anticlockwise (back to the starting position)</li> <li>Wait for 1 second</li> <li>Rotate the wheel 90\u00b0 clockwise</li> <li>Wait for 1 second</li> <li>Rotate the wheel 90\u00b0 anticlockwise</li> <li>Wait for 2 seconds, then repeat the sequence.</li> <li>On the serial monitor, you should display: <ul> <li>The time in seconds from the start of the demo<ul> <li>You should calculate this, not use the serial monitor time stamp</li> </ul> </li> <li>The PWM output to the motor</li> <li>The shaft position of the motor in degrees.</li> </ul> </li> </ol> <p>What do we expect to see in the demonstration?</p> <ul> <li>Demonstrate that you have fulfilled the requirements of the exercise with your working system.</li> <li>The rotational sequence for the output shaft as described above.</li> <li>An external power supply is used to power the motor circuit, (Vm on the driver board).</li> <li>Demonstration time in seconds, motor PWM value, control logic Boolean values to the driver board, and the motor shaft angle, are clearly labelled and displayed on the serial monitor.</li> <li>The serial monitor should update at a reasonable rate \u2013 2 to 4 times a second.</li> </ul> <p>Now Get Your Work Marked by a GTA</p> <p>Once you have completed your code and are satisfied with its operation, you should show your work to a GTA for marking.</p>"},{"location":"BasicExercises/Ex6EncodeMotor/#advanced-exercise-reading-multiple-encoders-efficiently-non-assessed","title":"Advanced Exercise: Reading multiple encoders efficiently. (Non-Assessed)","text":"<p>Note</p> <p>Note: This is a formative exercise and will not be assessed, but you may find it useful to complete, to help you with your group project.</p> <p>The aim of this exercise is to use the pin change interrupt on one of the input ports of the microcontroller, instead of the dedicated interrupt pins. (Note: this is a feature of AVR microcontrollers and may not be available on all devices or may be implemented slightly differently.)</p> <p>When controlling a mobile robot, it is usually necessary to read more than one encoder. Unfortunately, when using an Arduino UNO, the <code>attachInterrupt()</code> instruction can only be used with digital pins D2 and D3. Moving to a board with more I/Os, such as the Mega, solves the problem to some degree. Still, when dealing with a larger number of encoders, a more general approach may be required. </p> <p>A simple and efficient way of acquiring two or more encoders, is to use the pin change interrupts. The pins on a microcontroller are grouped in ports. On typical Arduino boards each port consists of up to 8 pins. These can be found by looking at a pinout diagram for the board in use, such as shown for the Arduino Uno in Fig 4.</p> Pinout of the Arduino UNO board. <p>In this exercise, you will consider the Port D pins on I/O D0 to D7, as illustrated in Fig 4.</p> <p>Note:</p> <p>This method does not use the Arduino libraries to use the interrupts. Instead, you will be interfacing with the microcontroller control resisters directly, unlike the interrupt pins method shown in Exercise 2, which uses the pre-build Arduino libraries.</p> <p>In order to use the pin change interrupts, you will need to:</p> <ul> <li>Determine which pins we wish to attach an interrupt to perform our operation.<ul> <li>Ideally this would be from a single port.</li> </ul> </li> <li>Enable the pin change interrupt for the port you wish to use.</li> <li>Select the pins we wish to use.</li> <li>Edit the associated interrupt service routine, ISR.<ul> <li>In your ISR, you will need determine which pin(s) has changed state and work accordingly.</li> </ul> </li> </ul> <p>This process is explained in more depth in the DroneBot Workshop article.</p> <p>The advantage of using this more advanced approach is that any pin on the microcontroller can be used to read encoder outputs, dramatically increasing the number of encoders that can be used in a system. Let us consider a system with two encoders attached to an Arduino Uno on pins D3, D4, D5, and D6, for the encoder 1 A &amp; B pins and the encoder 2 A &amp; B pins, respectively. As can be seen from Fig 4, all these pins are part of Port D on the Arduino Uno.</p> <p>The code below shows a snippet of code outlining a basic framework of how to initialise this process:</p> <ol> <li>Activate the pin change interrupts for PORT D, using the command: <code>PCICR |= 0b00000100;</code></li> <li>Reset the port D pin change mask to ensure correct operation: <code>PCMSK2 = 0;</code></li> <li>Select the interrupt pins of interest from the port D interrupt mask register: <code>PCMSK2 |= 0b01111000;</code></li> </ol> <p>The masking operation tells the microcontroller which pins it needs to listen to and which pins to ignore. This operation is needed to avoid the interrupt being triggered by changes in pins that are not connected to the encoders.</p> Basic framework for the pin change interrupt method, (code snippet)<pre><code>void setup()\n{\n  PCICR |= 0b00000100;\n  PCMSK2 = 0;\n  PCMSK2 |= 0b01111000;\n\n}\n\nvoid loop()\n{\n  // Put your main code here, to run repeatedly:\n}\n\n// This is the interrupt service routine for the Port D pin change interrupt\n// Nore: you cannot define the name for this ISR\nISR (PCINT2_vect){\n\n}\n</code></pre> <p>The interrupts are now only active on the 4 pins connected to the encoders, D3 to D6. When one of the pins changes its state, the function ISR(PCINT2_vect) is automatically executed. Note: PCINT2_vect is the interrupt request handler for PORT D and is required code work for the ISR.</p> <p>One method to measure the output of the attached encoders is to define a look-up table to modify the encoder counter. The look-up table output defines whether the encoder counter is incremented, decremented, or left unchanged, based on the values of pervious measured state and the current measured state of the encoder.</p> <p>We can define an encoder variable for each encoder, made up 4 bits of data arranged in the form, shown in Fig 5:</p> Arrangement of the encoder data variable. <p>Using this encoding, one can create the following table:</p> Prev. state Current state Resulting encoder variable, (above)RotationCount 00000000 = 0No0 00010010 = 1CCW-1 00100011 = 2CW1 00110100 = 3NA0 01000101 = 4CW1 01010110 = 5No0 01100110 = 6NA0 01110111 = 7CCW-1 10001000 = 8CCW-1 10011001 = 9NA0 10101010 = 10No0 10111011 = 11CW1 11011100 = 12NA0 11011101 = 13CW1 11101110 = 14CCW-1 11111111 = 15No0 Lookup tables for the encoder state and lookup table output. <p>Where: No = No rotation (current state = previous state), and NA = Not applicable (Impossible condition. Only one bit at a time can change)</p> <p>Note</p> <p>Analyse Table 2 and you\u2019ll see that the number of rows that have a +1 or -1 is 8, the same as the number of rows of Table 1. Try also comparing the rows between the two tables, to better understand how Table 2 was derived.</p> <p>The resulting 4-bit binary encoder variable produces a decimal number between 0 and 15. This number can then be used to index an array of data - the lookup table, comprising of the data in column 5 from Table 4. It is important to keep all entries, even the impossible ones, so that one can create the following lookup table array:</p> <p><code>static const int9_t lookup_table[] = {0,-1,1,0,1,0,0,-1,-1,0,0,1,0,1,-1,0};</code></p> <p>The code example in DualEncoderUsingPinChangeInterrupts.ino, presented below, provides the full code for reading 2 encoders on digital pins, D3, D4, D5, and D6, as described above.</p> <p>Procedure:</p> <ol> <li>Using the technique described above, modify your Arduino code that you wrote for Exercise 2 to use the pin change interrupt for a single encoder attached to pins D2 and D3. </li> <li>When you have this working, try changing the encoder connection pins and modify your script accordingly.</li> </ol> Example code for the pin change interrupt method: DualEncoderUsingPinChangeInterrupts.ino<pre><code>// Initialise the encoder counter variables\nvolatile long enc1_count = 0;\nvolatile long enc2_count = 0;\n\n// Intialise a variable to to record the tick counter value\nlong tickValue = 0;\n\nvoid setup() {\n\n  PCICR |= 0b00000100;   // Activate the port D pin change interrupt on the\n  // pin change interrupt control register\n  PCMSK2 = 0;            // Reset the port D pin change mask\n  PCMSK2 |= 0b01111000;  // Select the interrupt pins of interest from the\n  // port D interrupt mask register\n\n  // Define the pin modes dor D3, D4, D4, D6\n  pinMode(4, INPUT);\n  pinMode(5, INPUT);\n  pinMode(6, INPUT);\n  pinMode(7, INPUT);\n\n  // Open the serial port at 9600 baud\n  Serial.begin(9600);\n\n  tickValue = millis();  // Record an initial tick counter value\n}\n\nvoid loop() {\n\n  if (millis() &gt;= tickValue + 100) {  // if 100ms has elapsed sine the last\n  // time the followin code block ran\n\n    tickValue = millis();  // Record the current tick counter value\n\n    // Display the current encoder counter values on the serial monitor\n    Serial.print(\"Encoder 1 Count = \");\n    Serial.print(enc1_count);\n    Serial.print(\"\\tEncoder 2 Count = \");\n    Serial.println(enc2_count);\n  }\n}\n\n// This is the the interrupt service routine for the Port D pin change\n// interrupt\n// Note: you cannot define the name for this ISR\nISR(PCINT2_vect) {\n  static const int8_t lookup_table[] = {\n     0, -1, 1, 0, 1, 0, 0, -1, -1, 0, 0, 1, 0, 1, -1, 0 };\n  // Byte that stores the current and previous state of the encoder outputs\n  // for encoder 1\n  static uint8_t enc1_val = 0;\n  // Byte that stores the current and previous state of the encoder outputs\n  // for encoder 2\n  static uint8_t enc2_val = 0;\n\n  // Shift the previous current encoder value to the pervious position\n  enc1_val = enc1_val &lt;&lt; 2;\n\n  // The following line is a compound instruction:\n  // Read prot D and use an AND mask to remove bit information, then Shift\n  // the data relating to D3 and D4 to the first 2 bits. OR this with the\n  // enc1_val register to form the 4-bit current and previous encoder variable\n  enc1_Val = enc1_val | ((PIND &amp; 0b00011000) &gt;&gt; 3);\n\n  // Add the lookup table value relating to enc1_val to the encoder 1 counter\n  enc1_count += lookup_table[enc1_val &amp; 0b00001111];\n\n  // Shift the previous current encoder value to the pervious position\n  enc2_val = enc2_val &lt;&lt; 2;\n\n  // The following line is a compound instruction:\n  // Read prot D and use an AND mask to remove bit information, then Shift\n  // the data relating to D5 and D6 to the first 2 bits. OR this with the\n  // enc1_val register to form the 4-bit current and previous encoder variable\n  enc2_Val = enc2_val | ((PIND &amp; 0b01100000) &gt;&gt; 5);\n\n  // Add the lookup table value relating to enc2_val to the encoder 2 counter\n  enc2_count += lookup_table[enc2_val &amp; 0b00001111];\n}\n</code></pre> <p>Bitshift operations</p> <p>Bitshift operations are used to manipulate variables at a bit level. The right bit-shift operator (&gt;&gt;) is used to shift bits to the right (e.g. y=x&gt;&gt;3 means take x, shift the bits 3 positions to the right and save the results in y). The left bit-shift operator (&lt;&lt;) operates in a similar way but shifts bits to the left.</p> <p>Also Note</p> <p>After computing the encoder count, one still needs to convert it to revolutions of the encoder, or revolutions of motor shaft, using suitable constants.</p>"},{"location":"IntroMaterial/","title":"Introduction","text":"<p>This section is aimed at ensuring that there is a getting started guide to the Arduino IDE and a self paces tutorial structure for students with little/no programming experience. There are two documents in this section:</p> <ol> <li>The Supplementary Signposting Document to Accompany the introductory Exercises docyment: This document is aimed as a point of reference for students with little or no C programming experience. The document will provide reference links to external websites and the specific parts of the Arduino Language Reference pages, relating to elements of the Introductory exercises.</li> <li>The \"Getting Started\" Introductory Exercises are aimed at students that have little or no experience with Arduino and aimed at getting you started with installing and setting up the Arduino IDE, ready for use with these laboratory activities, and programming with simple I/O. These exercises are formative and non-assessed.</li> </ol> <p>To provide you with comprehensive instruction into C-programming is both outside the scope of this module and would take far more time than is available for the teaching/contact time allocated to this module. There are countless very good on-line resources for self-paced learning of programming languages. Therefore, instead of writing yet another tutorial, the Supplementary Signposting document should provide you with some signposts to resources for basic C programming topics that we think are necessary to facilitate the laboratory activities within this module.</p>"},{"location":"IntroMaterial/IntroExercises/","title":"Getting Started - Introductory Exercises (Non-assessed)","text":""},{"location":"IntroMaterial/IntroExercises/#the-arduino-ide","title":"The Arduino IDE","text":"<p>This section is aimed at providing you with a brief overview into installing and setting up the Arduino IDE, ready for use with these laboratory activities. There are two introductory exercises, presented, which should get you started with uploading code to the Arduino and </p>"},{"location":"IntroMaterial/IntroExercises/#the-installing-and-using-the-arduino-ide-on-a-university-managed-pc","title":"The Installing and Using the Arduino IDE on a University Managed PC","text":"<p>The Arduino software is available on all Managed University PC. In the Electronics and Control Laboratory, the software should already be installed on the workstation and laptop PCs. In other areas of the Diamond and the wider University campus, you may need to install Arduino using the Software Centre application.</p> <p>Note: As you should be aware, you can\u2019t download and install software on the University Managed PC from the internet.</p>"},{"location":"IntroMaterial/IntroExercises/#installation-and-setup-of-the-arduino-software-on-your-own","title":"Installation and Setup of the Arduino Software on your own","text":"<p>NOTE: The procedures laid out in this section are only for use on your home computer. The PCs you will be using in the University laboratories and computer rooms already have the Arduino software installed, or it must be installed from the Managed Desktop software Centre.</p> <p>Also Note: All the documentation for this module assumes you are using a Windows 10 or 11 on a PC. We do not support other operating system versions.</p> <p>Information about installing the Arduino IDE can be found on the Arduino website at: https://www.arduino.cc/en/Guide/Windows</p> <p>Procedure:</p> <p>Is This working</p> <ol> <li>Navigate to the Arduino IDE download page: https://www.arduino.cc/en/Main/Software download the appropriate version of the Arduino IDE for your operating system.</li> <li>Launch the Arduino IDE, to check it has been installed correctly</li> <li> <p>Ensure you have the latest version of the hardware drivers for the Arduino board:</p> <ul> <li>From within the Arduino IDE, select the Tools Menu and navigate to the Board Manager: Tools &gt; Board: [name is the current board] &gt; Boards Manager\u2026</li> <li>From the Boards Manager menu that appears on the left side of the Arduino IDE, Find the Arduino AVR Boards item and ensure the latest version of the driver is installed. You can check if there is a more up-to-date version by clicking on the dropdown box in the Arduino AVR Boards section, and seeing if there is a higher version available than the installed version indicated at the top of the section \u2013 do not install a lower version.</li> </ul> </li> <li> <p>At this point you should connect the Arduino Uno to your system and direct the Arduino IDE to the correct Arduino board type and Port to allow your Arduino device to be programmed.</p> <ul> <li>It you do not know how to do this, please look at the Getting Started with Arduino UNO guide on the Arduino website: https://www.arduino.cc/en/Guide/ArduinoUno</li> </ul> </li> </ol>"},{"location":"IntroMaterial/IntroExercises/#laboratory-exercises","title":"Laboratory Exercises","text":""},{"location":"IntroMaterial/IntroExercises/#simple-digital-io","title":"Simple Digital I/O","text":"<p>Note</p> <p>The remainder of this section is provided for students with no experience of using Arduino and serves as a tutorial example of how to use the Arduino IDE, in its most simple form.</p> <p>The Arduino microcontroller is a powerful tool to build a wealth of mechatronics and robotic projects. We are just getting started - so let\u2019s introduce how to work with push buttons and LEDs. These elements are digital inputs and outputs, and are representative of the type of actions we typically want in mechatronics projects: we want that upon a command (e.g., pressing a button), an action to take place that can modify the environment in a sensible way (e.g., a noticeable light on or off).</p> <p>Note</p> <p>Before starting the laboratory exercises, you should review the contents of the \"Mechatronics KIT Information\" folder, located in the Lab Practicals (Sem 1) content area of the Blackboard site for the Mechatronics course.</p>"},{"location":"IntroMaterial/IntroExercises/#intro-exercise-1-blink-example","title":"Intro Exercise 1: Blink Example","text":"<p>The aim of this exercise is to demonstrate how to upload and run a simple Arduino program.</p> <p>The Blink example is a good way to test the installation of your Arduino software, and also to identify if there is a major problem with your Arduino hardware.</p> <p>Procedure:</p> <ul> <li>Load the Blink example from the Arduino IDE files menu: Files &gt; Examples &gt; 01.Basics &gt; Blink, as shown in Fig. 1:</li> </ul> Screen shot of how to find the blink example in the Adruino IDE. <p>Note</p> <p>The built-in examples, provided in the Arduino IDE, are a great way of finding out how to do certain operations and use some programming constructs.</p> <ul> <li>You compile and upload your Arduino program, or Sketch, by pressing the Press Upload button, as highlighted with a red circle in Fig. 2:</li> </ul> A screen shot of the Upload button, highlighted with a red circuit, in the Arduino IDE. <p>After the IDE compiles and uploads your program, the Arduino should start to run your code. For this example, this will be indicated by the LED, \u201cL\u201d, (highlighted in Red in Fig. 3), which should be slowly flashing. (Note: LED \u201cL\u201d is also connected to pin 13).</p> The Arduino Board, with the LED, \u201cL\u201d, highlighted with a red box. <ol> <li>The setup() and loop() functions of the Blink example are shown below. Modify the values in the delay() functions, (highlighted in red) and investigate its effects again. What happens?</li> </ol> <p>(See the Arduino Language Reference, from the Arduino website, for details of the delay() function:https://www.arduino.cc/reference/en/language/functions/time/delay/)</p> <p>You should observe that changing the value in the brackets for the upper delay() function, changes the on-time of the LED, and changing the value of the lower delay function, changes the off-time for the LED.</p>"},{"location":"IntroMaterial/IntroExercises/#intro-exercise-2-push-button-and-led","title":"Intro Exercise 2: Push Button and LED","text":"<p>The aim of this exercise is to use a digital input, in this case from a push button, to trigger the Arduino to produce a digital output. In this case and LED, as illustrated in the circuit shown in Fig. 4.</p> <p>Wiring Procedure:</p> <ul> <li>Using the Kit of parts provided, connect the circuit as shown in Fig. 4.<ul> <li>It is not essential to maintain the colour of wires illustrated in the diagram.</li> <li>The digital input from the button is connected to pin 2</li> <li>The digital output to the LED is connected to pin 13, (shared with the LED \u201cL\u201d on the Arduino board)</li> <li>The resistor connected between the button and the GND line is 10K, and the resistor connected between the anode of the LED and pin 13 of the Arduino is 470\u2126.</li> </ul> </li> </ul> <p>Note</p> <p>There is a guide to reading resistor values in the Mechatronics Kit Information section of the Blackboard site.</p> <p>Note</p> <p>The digital Input, on pin 2, is \u2018pulled\u2019 down to the 0V supply rail by the a 10K resistor, (a resistor used in this manner is often referred to as a pull-down resistor). In this configuration, when we press the button, the digital input is connected to the +5V supply rail. When the button is released, the 10K resistor \u2018pulls\u2019 the digital input back down to 0V. without the 10K resistor, the input would \u2018float\u2019, and may produce a spurious input when the button is released.</p> Diagram illustrating the Circuit configuration for the Push Button and LED Exercise. <p>The code for this exercise can be found by selecting the in-built Button exercise from the Files menu in the Arduino IDE: Files &gt; Examples &gt; 02.Digital &gt; Button</p> <p>Procedure:</p> <ul> <li>Run Button example Arduino sketch: you should see the LED light up when you press the button, and the LED should go out when you release the button.</li> </ul> <p>Note</p> <p>It is often the case that we may wish to view data directly from within an Arduino program. To achieve this we can use the Serial library to stream data from the Arduino, across a COM interface (this can be the same COM port you are using to program the Arduino) to a terminal \u2013 we can use the Serial Monitor in the Arduino IDE for convenience.</p> <p>The modified Button example code, shown below, is based on the Button example, but has the following two extra lines:</p> <pre><code>// Initialise communications with the serial monitor. Parameter: baud rate\nSerial.begin(9600);\n\n...and\n\n// Write the value of the buttonState variable to the serial monitor\nSerial.println(buttonState);\n</code></pre> <p>These extra commands initialise the Serial interface, and write data to the COM port. A description of the Serial commands can be found in the Serial functions section of the Arduino reference guide:</p> <p>https://www.arduino.cc/reference/en/language/functions/communication/serial/</p> <p> Modified Button Example<pre><code>// constants won't change. They're used here to set pin numbers:\nconst int buttonPin = 2;  // the number of the push button pin\nconst int ledPin = 13;    // the number of the LED pin\n\n// variables will change:\nint buttonState = 0;  // variable for reading the push button status\n\nvoid setup() {\n  // Initialise communications with the serial monitor. Parameter: baud rate\n  Serial.begin(9600);\n\n  // initialize the LED pin as an output:\n  pinMode(ledPin, OUTPUT);\n  // initialize the push button pin as an input:\n  pinMode(buttonPin, INPUT);\n}\n\nvoid loop() {\n  // read the state of the push button value:\n  buttonState = digitalRead(buttonPin);\n\n  // Write the value of the buttonState variable to the serial monitor\n  Serial.println(buttonState);\n\n  // check if the push button is pressed. If it is, the buttonState is HIGH:\n  if (buttonState == HIGH) {\n    // turn LED on:\n    digitalWrite(ledPin, HIGH);\n  } else {\n    // turn LED off:\n    digitalWrite(ledPin, LOW);\n  }\n}\n</code></pre></p> <p>Links to all the Serial function descriptions are listed towards the bottom of the Serial commands reference page.</p> <p>To open the Serial Monitor, from the Arduino IDE, click the button in the top right of the IDE, as highlighted in Fig. 5.</p> Screen shot of the Serial Monitor button, in the Arduino IDE. <p>Procedure:</p> <ul> <li>Modify the Button example sketch, and open the Serial Monitor</li> <li>Run the code: You should see a \u20181\u2019 printed on the serial monitor when the button is pressed, and the serial monitor should display \u20180\u2019 when the button is released.</li> </ul>"},{"location":"IntroMaterial/SupplSignPost/","title":"Supplementary Signposting Document to Accompany The Introductory Exercises","text":""},{"location":"IntroMaterial/SupplSignPost/#pre-face","title":"Pre-face","text":"<p>This document is aimed at students with little or no C-programming experience, but maybe used as a signposted reference for anyone. For students with little or no C-programming experience, this document can be used in parallel to the  Introductory Exercises document. This document provides structured signposted links to the Learn-C tutorial website, C-Programming.com, the Arduino programming reference, and also links in some of the early exercises from the Introductory Exercises document.</p> <p>Students with some C-programming skills may wish to skip this document, and go on to the only use the Introductory Exercises document or skip these and go straight to the first of the assessed exercises: Basic: LED Pattern</p>"},{"location":"IntroMaterial/SupplSignPost/#introduction","title":"Introduction","text":"<p>In previous years it has become evident that some groups of students, taking the Mechatronics modules, do not have any background experience on programming in C/C++ or experience with using Arduino or other microcontroller based development systems. As a result, these students have struggled with some of the basics of the Mechatronics laboratory activities, due to not having learned any C-programming skills before starting this module.</p> <p>To provide you with comprehensive instruction into C-programming is both outside the scope of this module and would take far more time than is available for the teaching/contact time allocated to this module. There are countless very good on-line resources for self-paced learning of programming languages. Therefore, instead of writing yet another tutorial, this document will provide you with some signposts to resources for basic C programming topics that we think are necessary to facilitate the laboratory activities within this module. </p> <p>Note</p> <p>This document is not aimed at providing you with a comprehensive list of topics required for this module, and it may be necessary for you to discover further resources to improve your programming knowledge and skills.</p> <p>In this iteration of this document we will signpost some of the tutorial resources from Learn-C, sections from C-Programming.com, and the programming references and examples/tutorials from the Arduino website.</p> <p>It will be up to you to self-guide your own learning to improve your skills and understanding, required for the labs and your project activities, and if necessary discover further resources. (If you do find topics/resources that you think would be of benefit, please make us aware of these, and if appropriate, we may provide further sign posting to these materials.)</p> <p>The remaining subsections of the introduction highlight some resources you may find useful whilst going through the remainder of this document, and while you are completing the mechatronics module laboratory exercises and project.</p>"},{"location":"IntroMaterial/SupplSignPost/#external-tutorial-websites-linked-from-this-document","title":"External tutorial websites linked from this document","text":"<p>The tutorials provided on Learn-C are aimed at programming for computer systems, (PC, Linux, etc), and not specifically for embedded C-programming, the likes of which we will be doing on the Arduino platform. As a result, there are some slight differences in the structure of the Arduino programs, or \u2018Sketches\u2019 as they are known. However, these Learn-C tutorials provide a good introduction to the basics of C programming, and we have supplemented them with signposted information from the Arduino website.</p> <p>Each Learn-C tutorial provides a short introduction to each topic and has an on-line compiler that allows you to practice parts of each tutorial exercise, and topics discussed. These should provide sufficient background for you to complete the Mechatronics laboratory exercises.</p> <p>Another useful resource is C-Programming.com, (again aimed at programming for computer systems), which provides a more in depth overview/tutorial for learning C, and you may only wish to consider the lessons from the \u201dIntroduction and Basic C Features\u201d section of the C-Tutorial</p> <p>Note</p> <p>In the next section of this document we have selected relevant sections from the C-Programming.com and C-Programming.com websites, and linked them with relevant material from the Arduino language guide. It is suggested that you access these tutorials as instructed in the following sections. </p>"},{"location":"IntroMaterial/SupplSignPost/#arduino-language-reference","title":"Arduino Language Reference","text":"<p>The Arduino programming reference is a web page, within the Arduino website, which provides a complete reference for Arduino functions, variables and programming structures for the core Arduino language. The language reference may seem a little daunting to a novice programmer, but is a very useful resource when you have some experience with Arduino programming. </p> <p>Note</p> <p>Relevant sections of the Arduino programming reference are linked throughout the remainder of this document, therefore, it is not necessary to read it before proceeding.</p>"},{"location":"IntroMaterial/SupplSignPost/#arduino-build-in-examples-within-the-arduino-ide","title":"Arduino Build-in Examples within the Arduino IDE","text":"<p>There is a tutorials section within the Arduino web site, which provides you with a large range of tutorials, from simple getting started guides for the software and hardware, through to the descriptions of the Arduino Software\u2019s build-in examples. There are also links into tutorials on the Arduino Project Hub, and links to other more advanced topics to help expand your capabilities.</p> <p>Some of the links sections within the tutorials section section may be useful when you come to do your project.</p>"},{"location":"IntroMaterial/SupplSignPost/#introduction-to-programming-an-arduino-in-c","title":"Introduction to Programming an Arduino in C.","text":"<p>The remainder of this document is aimed at providing you with a structured set of signposted links to help build your understanding of the basics of C-programming. This document will signpost you to a number of tutorials on the Learn-C website, and interweave these with signposted links to relevant sections of the Arduino programming reference, and some of the early exercises from the Introductory Exercises document. </p> <p>The Arduino programming libraries are a series of C/C++ functions that can be called from the code you write. The native programming languages for Arduino are either C or C++. Throughout the remainder of this module, we will only be considering programming Arduino in C. </p> <p>(For those interested, there is a brief overview and history of the C-programming language on the Wikipedia site.)</p>"},{"location":"IntroMaterial/SupplSignPost/#hello-world-example","title":"Hello World Example","text":"<p>A typical place to start with any programming language is the \u201cHello World\u201d example - (See the \u201cHello World\u201d example from the Learn-C Tutorial), this illustrates the basic structure of a programming language, using a program that writes the words \u201cHello World\u201d to the \u201cstandard output\u201d. </p> <p>The Standard Output in Arduino</p> <p>In Arduino, there is no standard output, because it is an embedded operating system operating without a console terminal. Generally, we direct the standard output to the serial monitor in the Arduino IDE. This will be discussed in a later section.</p> <p>The following programming syntax, (linked from the Arduino language reference), are necessary for correct implementation of your code:</p> <ul> <li>Semicolon</li> <li>Curly braces</li> </ul> <p>Code comments are a readable explanation or annotation of the code that you have written. You should provide comments throughout your code to help explain what you have written and why you have written it in that way. Code comments are an invaluable tool to help you debug code that is not working in the manner intended, and should be updated when code is changed. Links to how to implement code commenting in Arduino:</p> <ul> <li>Single Line Comment</li> <li>Block Comment</li> </ul> <p>Simple Macros are a very useful tool when writing clear and effective embedded code, not only helping with the readability of your code, but also help when trying to debug your work. The #define directive replace a constant numeric value throughout your code, with a simple name defined in the global namespace. This can simplify the readability of your code and allow you to quickly update these distributed constants from a single location. The #define can also be used to create macros for small blocks of instructions, but care must be used, because it may be more appropriate to use a function instead.</p> <p>Whilst programming, you may wish to link an external library into your Arduino code. The #include directive can be used to link external libraries into your work, such as an external library of code to interface a servo device.</p>"},{"location":"IntroMaterial/SupplSignPost/#variables-and-numbers","title":"Variables and Numbers","text":"<p>One of the key considerations when programming computer systems and embedded systems, is the handling and storage of different types of numbers. The Variables and numbers - tutorial from Learn-C provides a brief introduction to this, but does not consider the conversion between data types. See the variables section of Arduino Language Reference for a more detailed list of variable types and commands used to convert between them.</p> <p>(Also see the Using Variables section of the Introduction to C lesson from C-Programming.com)</p> <p>Arrays are a data structure that is essentially a list/collection of values of the same data type, arranged in an indexed manner - See Arrays - Learn-C Tutorial, and the Array section of the Arduino Language Reference. Multidimensional arrays can also store multidimensional data, by employing more than one set of indexes, e.g. a 2-dimensional array would be arranged similar to a spreadsheet of data and would have 2 sets of indices. </p> <p>(Another, and more comprehensive, reference for Arrays in C, is provided in lesson-8 of C Tutorial in C-Programming.com.)</p>"},{"location":"IntroMaterial/SupplSignPost/#functions","title":"Functions","text":"<p>Functions are blocks of code that perform a predefined set of commands, and are either used to \u2018tidy-up\u2019 your code to make it more readable, or to perform repeated activities. As you write your Arduino code, you will be using some of the built-in and 3rd party library functions, and you may also wish to define your own. Functions are discussed in the Learn-C, Functions tutorial and the Functions in C lesson from C-Programming.</p>"},{"location":"IntroMaterial/SupplSignPost/#blink-example-introductory-exercise","title":"Blink Example - Introductory Exercise","text":"<p>The blink example is used in the Introductory Exercises, and can be accessed from the Arduino IDE files menu : </p> <p>Files &gt; Examples &gt; 01.Basics &gt; Blink</p> <p>The in-build example tutorial for the Blink program is provided in the Arduino Tutorial section of the website. (Note: Arduino suggest using a 220\ud835\udefa resistor, but in Exercise 1 will instruct you to use a 470\ud835\udefa resistor.)</p> <p>The Blink example code is a simple test program, often used to ensure the Arduino compiler is working correctly, and the hardware can communicate with the IDE correctly. Look at the Arduino code example, there are three sections to the code:</p> <ul> <li>Global namespace - area at the top of the code used for declaration of global variables and location for compiler directives, such as #define and #include instructions</li> <li>setup() function - This function runs once at the start of the program and is generally used to initialise variables, hardware and libraries, and to define I/O pin modes.</li> <li>loop() function - This function is the generally main body of your Arduino program, and loop continuously, allowing your system hardware to be read and controlled each loop iteration.</li> </ul> <p>You will notice the use of the delay() function. This is a simple time delay function used to control the execution of your code.</p> <p>At this point is worth signposting:</p> <ul> <li>The while loop is a programming structure that will continuously loop until a logical termination is satisfied</li> <li>The for loop is a programming structure that will loop for a pre-specified number of iterations.</li> </ul> <p>Learn-C provides tutorials for the for loop and the while loop structures. Both of these structures are discussed on Loops in C lesson from C-Programming.com. The Arduino Language reference also has sections for the for loop and the while loop structures</p>"},{"location":"IntroMaterial/SupplSignPost/#decision-making","title":"Decision making","text":"<p>One of the basic tasks we use computer systems for is decision making, based on logical conditions and inputs. The Learn-C Conditions tutorial provides an introduction to using the if statement on C. The Arduino language reference for the if statement is linked here, but you should also look at the different logical and comparison operation from the Arduino language reference, located in the structures section. The if statement, logical and relational operators are also discussed in the If Statements in C lesson of C-Programming.com.</p> <p>At this point it is worth mentioning the switch case structure in C. This is a more advanced topic but you may find it a useful programming structure for your projects: Arduino language reference and C-Programming.com lesson.</p> <p>The switch case structure can be used in the place of a long if structure that uses a definite value of a control variable to select one or more blocks of code to be executed. Switch case structures and widely used when programming state machine type behaviour. </p> <p>Finite state machines are a useful conceptual design tool when implementing sequenced and decision-based behaviour. You may find them useful when implementing the software for your project, but they will not be further discussed in this material.</p>"},{"location":"IntroMaterial/SupplSignPost/#serial-monitor","title":"Serial Monitor","text":"<p>As previously mentioned, there is no standard output for Arduino hardware. When using Arduino hardware, a serial terminal is often used to read user generated messages from the Arduino hardware, or to stream variable values to a readable interface. The Serial Monitor, in the Arduino IDE, provides a convenient serial terminal to view text based messages generated from your Arduino code.</p> <p>The Instructables.com \u201cHOW-TO Use the ARDUINO SERIAL MONITOR\u201d how-to web page provides an insight into the use of the serial monitor. You will notice that the code provided in this tutorial uses a number of the serial communications functions, which are described in the Arduino language reference. Data sent across the serial interface to the serial monitor.</p>"},{"location":"IntroMaterial/SupplSignPost/#the-string-data-type","title":"The string data type","text":"<p>Before using the serial monitor it is worth going through the Learn-C Tutorial on Strings, and being aware of the String as an array of characters section and the String DataType object section of the Arduino language reference.</p>"},{"location":"IntroMaterial/SupplSignPost/#push-button-and-led-example-introductory-exercise","title":"Push button and LED Example - Introductory Exercise","text":"<p>The Push button and LED example is based on the Button example from the in-built Arduino examples - the tutorial for the Button example is linked, here. The code provided in the laboratory worksheet demonstrates how the serial monitor can be incorporated into an Arduino program, to monitor an internal variable within the code.</p>"},{"location":"IntroMaterial/SupplSignPost/#final-comment","title":"Final Comment","text":"<p>The signposting of background C programming resources provided in the previous sections of this document should be sufficient for you to implement the remaining laboratory work in this Mechatronics module. You may wish to find further resources, either on-line or in print, to help you practice your C programming skills, but you will need to discover these yourself.</p> <p>If you do find further topics/resources that you think would be beneficial in enriching this document, please make us aware of these topics/resources. If appropriate, we may use some of these resources to improve future iterations of this document</p>"}]}